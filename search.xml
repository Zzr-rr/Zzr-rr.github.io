<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于搭建博客的一些基础知识</title>
      <link href="/2023/09/06/2023-9-6-%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/09/06/2023-9-6-%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="博客的框架"><a href="#博客的框架" class="headerlink" title="博客的框架"></a>博客的框架</h2><p>​        我的个人博客采用的是hexo，简单介绍一下hexo，便于对博客的基本框架有一定的了解。</p><p>​        Hexo是基于Node.js的静态博客生成器，并且允许使用markdown的语法编写博客文章，并将其转化为静态HTML文件，最后在网站上展示。</p><p>​        Hexo本身是一个静态页面生成器，因此不支持动态内容，如实时评论，用户交互等，但是可以通过其它服务或者工具来集成此类功能。如Disqus、Gitalk、Valine等。</p><p><strong>了解一下几个基本概念</strong></p><p><strong>Node.js</strong></p><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于在服务器端运行 JavaScript 代码。与传统的浏览器端JavaScript不同，它提供了许多额外的API和模块，使得开发者能够访问底层操作系统的功能，比如文件系统、网络通信、操作进程等。这使得开发者可以使用JavaScript来构建服务器、命令行工具、网络应用、实时应用程序等等。</p><p><strong>NPM</strong></p><p>NPM是Node.js配套的包管理器，是世界上最大的开源软件库，什么意思呢，诸如jquery、bootstrap一类的文件都可以通过NPM下载到，程序员们如果下载什么都需要到它本身的官网上去下载，这显然是一件很麻烦的事，而NPM的出现就是为了解决这一问题，它将所有文件的包都放在了托管的平台上，程序员们只需要通过NPM就能将这些包下载下来，大大减少了人们的工作量。</p><p><strong>Git</strong></p><p>Git是一个分布式版本控制系统，用于跟踪文件和代码的变化，并协调多个开发者之间的协作功能，在开发一个大型项目时，使用git可以记录项目发生的变化，负责这一项目的程序员们也可以通过pull操作将项目下载下来在本地修改，各自托管自己负责的项目，再通过push操作将项目更新。</p><h2 id="Hexo的基本框架"><a href="#Hexo的基本框架" class="headerlink" title="Hexo的基本框架"></a>Hexo的基本框架</h2><p>​        了解了博客是由哪些工具生成，我们来解读一下Hexo的源码，找出我们平时需要在维护哪些部分。Hexo是台湾人写的，在<a href="https://hexo.io/zh-cn/docs/">官方文档</a>这方面对国人还是相当友好的。</p><h3 id="网站框架"><a href="#网站框架" class="headerlink" title="网站框架"></a>网站框架</h3><h4 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- _config.landscape.yml</span><br><span class="line">|-- _config.yml</span><br><span class="line">|-- db.json</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- package-lock.json</span><br><span class="line">|-- package.json</span><br><span class="line">|-- public</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">`-- themes</span><br></pre></td></tr></table></figure><p>上述是通过Hexo创建框架之后自动生成的文件夹，较为重要的有以下几个.</p><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h4><p>其中包含了我们的配置文件，包括主题的配置，插件，部署等等，你可以在这个文件中设置博客的标题、描述、作者、默认语言、主题、插件等信息，设置完成之后需要重新生成静态文件使其生效。</p><p>和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启 Hexo Server。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a><code>source</code></h4><p>包含了我们的资源文件，像我们写的md格式的文章以及相关的资源图都放在里面。</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a><code>public</code></h4><p>它会在我们每次使用命令<code>hexo generate</code>后生成一系列文件，用于存储生成的一系列静态网页。hexo在生成网页时，会将你的Markdown文章和主题模板转换成HTML文件，并将这些生成的文件保存在<code>public</code>文件夹中。</p><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h4><p>这是 Hexo 的插件配置文件，也位于博客根目录下。它定义了博客所使用的插件及其版本信息。当你安装或更新插件时，<code>package.json</code> 文件会被相应地更新。可以通过命令行运行 <code>npm install</code> 来安装 <code>package.json</code> 中定义的插件。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a><code>themes</code></h4><p>这个是存放主题的文件夹，通过在<code>_config.yml</code>文件中修改主题的配置即可切换主题。</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>我个人使用的主题是<code>butterfly</code>，它有较为完整的<a href="[Butterfly 安裝文檔(一">文档</a> 快速開始 | Butterfly](<a href="https://butterfly.js.org/posts/21cfbf15/))。">https://butterfly.js.org/posts/21cfbf15/))。</a></p><blockquote><p>在 hexo 的根目录创建一个文件<code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复制到 <code>_config.butterfly.yml</code>去，以后就只需要在<code>_config.butterfly.yml</code>中配置即可，原来的<code>_config.yml</code>就会失效。</p></blockquote><h3 id="文章框架"><a href="#文章框架" class="headerlink" title="文章框架"></a>文章框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line">XXX文章内容</span><br></pre></td></tr></table></figure><p>在文章的开头会预定义一些参数，如title定义标题，标定文章的标题，有一些标签需要特别注意，在这里我讲解一下。</p><h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><p>在这里引用一下官方原文，讲解的很清晰。</p><blockquote><p>官方原话：</p><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p></blockquote><p>定义的格式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><p>这样的定义代表了这篇文章的分类属于<code>Diary</code>，并且有两个标签<code>PS3</code>和<code>Games</code>。</p><p>如果这样定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>就会使得<code>Life</code>称为<code>Diary</code>的子分类，而不是并列分类。如果需要添加并列分类，是这样的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1123.最深叶节点的最近公共祖先</title>
      <link href="/2023/09/06/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/09/06/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="1123-最深叶节点的最近公共祖先"><a href="#1123-最深叶节点的最近公共祖先" class="headerlink" title="1123. 最深叶节点的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/">1123. 最深叶节点的最近公共祖先</a></h2><p><img src="/images/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20230906110858312.png" alt="image-20230906110858312"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        题目给定三个条件：</p><ol><li>树中的节点数将在[1, 1000]的范围以内。</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li>每个节点的值都是独一无二的。</li></ol><p>​        读题，如果只有一个最深叶节点，那么它本身就是它的最深叶节点。如果有两个最深叶节点，我们就应该找到一个节点，使之这两个叶节点能够存在与这两个节点的左右子树中。</p><p>​        注意到题目的节点数最大不过为1000，因此即便使用$O(n^2)$的算法也不会超时。</p><p>​        可以先遍历一遍二叉树，找到二叉树的最大深度，记为<code>max_depth</code>，再遍历一遍二叉树，判断某个节点的左右子树是否包含这个最深节点，即<code>if node1(depth==max_depth) in root-&gt;left and node2(depth==max_depth) in root-&gt;right</code>，且最好是从下往上去找，因为节点的值都是独一无二的，<strong>我们可以记录每一条到达二叉树的最深节点的路径，根据值的相等与否就能找到相应的祖先。如果路径数为1，那么就返回它本身，它本身就是最深节点的公共祖先。</strong></p><p>举几个例子，图中到达最深节点的路径有两条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 5, 2, 7] 和 [3, 5, 2, 4]，其中2是离他们最近的公共祖先。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对[0, 1, 3, null, 2]这颗二叉树，到达最深节点的路径有一条：</span><br><span class="line"></span><br><span class="line">[0, 1, 2]，那么2就是离它最近的公共祖先。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对[1, 2, 3, 4, 5, 6, 7, null, null, 8, null, 9, 10, 11, 12]这颗二叉树，到达最深节点的路径有五条：</span><br><span class="line"></span><br><span class="line">[1, 2, 4, 8]</span><br><span class="line"></span><br><span class="line">[1, 2, 5, 9]</span><br><span class="line"></span><br><span class="line">[1, 2, 5, 10]</span><br><span class="line"></span><br><span class="line">[1, 3, 6, 11]</span><br><span class="line"></span><br><span class="line">[1, 3, 6, 12]</span><br></pre></td></tr></table></figure><p>要找它们的最近公共祖先，就是它们几个中相等值的最后一位，记为<code>parent</code>。</p><p>最后遍历一遍二叉树，<code>node-&gt;val == parent</code>就是我们要的那个节点。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先取到二叉树的最大深度</span></span><br><span class="line">        <span class="type">int</span> max_depth = <span class="built_in">depth</span>(root, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; max_depth &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取遍历到最大深度的路径</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">dp_path</span>(root, path, res, max_depth);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历最大路径，找到相等的值中最后一个</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = res[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            num = res[<span class="number">0</span>][i]; <span class="comment">// 先记录某一个可能的值，再进行接下来的遍历。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j][i] != num)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到节点对应的值之后，找到对应的节点</span></span><br><span class="line">        TreeNode* node = <span class="built_in">dfs</span>(root, num);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* root, <span class="type">int</span> dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left, dp), <span class="built_in">depth</span>(root-&gt;right, dp));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dp_path</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; path, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res, <span class="type">int</span> max_depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == max_depth)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dp_path</span>(root-&gt;left, path, res, max_depth);</span><br><span class="line">        <span class="built_in">dp_path</span>(root-&gt;right, path, res, max_depth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == num)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* l = <span class="built_in">dfs</span>(root-&gt;left, num);</span><br><span class="line">        TreeNode* r = <span class="built_in">dfs</span>(root-&gt;right, num);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2023/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/"/>
      <url>/2023/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>​        本篇文章将持续记录刷题过程中常见的数据结构与基本操作。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算是一种对二进制数进行操作的运算。在计算机中，所有的数据都是以二进制形式存储的，位运算可以直接对二进制数的每一位进行操作，因此在一些场合下，位运算比其他运算更加高效。</p><p>对于一个数组<code>&#123;0, 2, 3&#125;</code>，我们可以存储一个二进制数，对应下标的数如果存在，则二进制该位为1，否则为0，比如说<code>0</code>在该数组中，那么该二进制数的<code>0</code>位就为1，按照<strong>从低位到高位</strong>依次类推，我们可以用<code>1101</code>表示数组<code>&#123;0,2,3&#125;</code>；再举个例子，比如说<code>&#123;1,2,3&#125;</code>可以用二进制数<code>1110</code>来表示。</p><h2 id="位运算在集合方面的应用"><a href="#位运算在集合方面的应用" class="headerlink" title="位运算在集合方面的应用"></a>位运算在集合方面的应用</h2><p>了解了位运算的基本概念之后，我们可以尝试在模拟一些集合的操作。</p><p>{1, 2, 3, 5, 7} {0, 2, 4, 5 ,7}</p><ol><li>对于求交集的操作</li></ol><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>​        哈希表（Hash table），国内也有一些算法的书籍称它为散列表，<strong>一般哈希表都是用来快速判断一个元素是否出现在集合里</strong>。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>​        将关键码和值对应的过程就叫做哈希映射，这其中涉及到了hash function， 也就是哈希函数。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>​        哈希函数通过<code>hashCode</code>将名字转化为数值，映射到哈希表上的索引数字。进行取模的操作防止索引数字超过了<code>tableSize</code>。但是这避免不了有几位学生的名字同时映射到了同一个索引下标的位置，因此引入了哈希碰撞。</p><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223821997.png" alt="image-20230905223821997">        </p><p>​        如图，小李和小王都映射到了索引下标为1的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p>​        一般对于哈希碰撞，有两种解决方法，拉链法和线性探测法。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223859549.png" alt="image-20230905223859549"></p><p>​        </p><p>（数据规模为<code>dataSize</code>，哈希表的大小为<code>tableSize</code>）        </p><p>发生冲突的位置用链表去存储，这样就可以通过索引找到小李和小王了。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>如果使用线性探测法，一定要保证<code>tableSize&gt;dataSize</code>。我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>即如果1存放了小李，下次小王又需要在1中存储时，那么小王会被放在了2的位置。所以要求<code>tableSize&gt;dataSize</code>，不然就没有空位来存放冲突的数据了。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223906320.png" alt="image-20230905223906320"></p><h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p>当我们遇到需要使用哈希法来解决问题的时候，我们一般会选择如下的三种数据结构。</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>其上的几个例子就是数组的代表，我们重点关注一下set。</p><p>在C++中，set和map分别提供了以下三种数据结构，其底层实现以及优劣如下表所示。</p><div class="table-container"><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p><code>std::unordered_set</code>底层实现为哈希表，<code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，<strong>红黑树是一种平衡二叉搜索树</strong>，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><div class="table-container"><table><thead><tr><th style="text-align:left">映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td style="text-align:left">std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td style="text-align:left">std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td style="text-align:left">std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p><code>std::unordered_map</code>底层实现为哈希表，<code>std::map</code> 和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用<code>unordered_set</code>，因为它的<strong>查询和增删效率是最优的</strong>，如果需要集合是有序的，那么就用<code>set</code>，如果要求不仅有序还要有重复数据的话，那么就用<code>multiset</code>。</p><p>那么再来看一下<code>map</code> ，在<code>map</code>是一个<code>key-value</code>的数据结构，<code>map</code>中，对<code>key</code>是有限制，对<code>value</code>没有限制的，因为key的存储方式使用红黑树实现的。</p><p>其他语言例如：<code>java</code>里的<code>HashMap</code>，<code>TreeMap</code> 都是一样的原理。可以灵活贯通。</p><p>虽然<code>std::set</code>、<code>std::multiset</code>的底层实现是红黑树，不是哈希表，<code>std::set</code>、<code>std::multiset</code>使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即<code>key</code>和<code>value</code>。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。<code>map</code>也是一样的道理。</p><p>这里在说一下，一些C++的经典书籍上 例如<code>STL</code>源码剖析，说到了<code>hash_set hash_map</code>，这个与<code>unordered_set</code>，<code>unordered_map</code>又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是<code>unordered_set</code>在C++11的时候被引入标准库了，而<code>hash_set</code>并没有，所以建议还是使用<code>unordered_set</code>比较好，这就好比一个是官方认证的，<code>hash_set</code>，<code>hash_map</code>是C++11标准之前民间高手自发造的轮子。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230906223917132.png" alt="image-20230906223917132"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建-hexo</title>
      <link href="/2023/09/05/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/09/05/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><p><strong>前置知识：</strong></p><ul><li>HTML</li><li>CSS</li><li>JavaScript、jQuery</li></ul><p><strong>快速建站教程</strong></p><p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">Hexo-零基础搭建个人博客(详解)</a></p><p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210806984-1694011364573-1.png" alt="image-20230905210806984"></p><p><strong>推送至gitee仓库</strong></p><p>_config.yml文件中进行如下的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://gitee.com/zzr-rr/zzr-rr.gitee.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>在执行推送命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">推送命令</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>扩展：</p><p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p></blockquote><p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210828138.png" alt="image-20230905210828138">推送完成的界面。</p><p>由于gitee有一堆显示，我将他连接到github，并且部署到我的仓库。</p><p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210856266.png" alt="image-20230905210856266"></p><p>了解一下hexo吧，hexo的基本配置 <code>.config.yaml</code>文件下的各种参数</p><p><strong>网站</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table></div><p><strong>网址</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>permalink</code></td><td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr></tbody></table></div><p><strong>如何对hexo网站进行修改，参考hexo的官方文档</strong></p><p><a href="https://hexo.io/zh-cn/api/">API | Hexo</a></p><h3 id="在git过程中遇到的一些问题"><a href="#在git过程中遇到的一些问题" class="headerlink" title="在git过程中遇到的一些问题"></a>在git过程中遇到的一些问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/Zzr-rr/Zzr-rr.github.io.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>打开<code>git bash</code>，解除SSL认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><p>git可能隔一段时间就会出现这个问题，及时修改即可。</p><p>因为是国外的网站，github经常连接超时，隔一段时间试试。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
