<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于搭建博客的一些基础知识</title>
    <url>/2023/09/06/2023-9-6-%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="博客的框架"><a href="#博客的框架" class="headerlink" title="博客的框架"></a>博客的框架</h2><p>​        我的个人博客采用的是hexo，简单介绍一下hexo，便于对博客的基本框架有一定的了解。</p>
<p>​        Hexo是基于Node.js的静态博客生成器，并且允许使用markdown的语法编写博客文章，并将其转化为静态HTML文件，最后在网站上展示。</p>
<p>​        Hexo本身是一个静态页面生成器，因此不支持动态内容，如实时评论，用户交互等，但是可以通过其它服务或者工具来集成此类功能。如Disqus、Gitalk、Valine等。</p>
<p><strong>了解一下几个基本概念</strong></p>
<p><strong>Node.js</strong></p>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于在服务器端运行 JavaScript 代码。与传统的浏览器端JavaScript不同，它提供了许多额外的API和模块，使得开发者能够访问底层操作系统的功能，比如文件系统、网络通信、操作进程等。这使得开发者可以使用JavaScript来构建服务器、命令行工具、网络应用、实时应用程序等等。</p>
<p><strong>NPM</strong></p>
<p>NPM是Node.js配套的包管理器，是世界上最大的开源软件库，什么意思呢，诸如jquery、bootstrap一类的文件都可以通过NPM下载到，程序员们如果下载什么都需要到它本身的官网上去下载，这显然是一件很麻烦的事，而NPM的出现就是为了解决这一问题，它将所有文件的包都放在了托管的平台上，程序员们只需要通过NPM就能将这些包下载下来，大大减少了人们的工作量。</p>
<p><strong>Git</strong></p>
<p>Git是一个分布式版本控制系统，用于跟踪文件和代码的变化，并协调多个开发者之间的协作功能，在开发一个大型项目时，使用git可以记录项目发生的变化，负责这一项目的程序员们也可以通过pull操作将项目下载下来在本地修改，各自托管自己负责的项目，再通过push操作将项目更新。</p>
<h2 id="Hexo的基本框架"><a href="#Hexo的基本框架" class="headerlink" title="Hexo的基本框架"></a>Hexo的基本框架</h2><p>​        了解了博客是由哪些工具生成，我们来解读一下Hexo的源码，找出我们平时需要在维护哪些部分。Hexo是台湾人写的，在<a href="https://hexo.io/zh-cn/docs/">官方文档</a>这方面对国人还是相当友好的。</p>
<h3 id="网站框架"><a href="#网站框架" class="headerlink" title="网站框架"></a>网站框架</h3><h4 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- _config.landscape.yml</span><br><span class="line">|-- _config.yml</span><br><span class="line">|-- db.json</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- package-lock.json</span><br><span class="line">|-- package.json</span><br><span class="line">|-- public</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">`-- themes</span><br></pre></td></tr></table></figure>
<p>上述是通过Hexo创建框架之后自动生成的文件夹，较为重要的有以下几个.</p>
<h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h4><p>其中包含了我们的配置文件，包括主题的配置，插件，部署等等，你可以在这个文件中设置博客的标题、描述、作者、默认语言、主题、插件等信息，设置完成之后需要重新生成静态文件使其生效。</p>
<p>和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启 Hexo Server。</p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a><code>source</code></h4><p>包含了我们的资源文件，像我们写的md格式的文章以及相关的资源图都放在里面。</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a><code>public</code></h4><p>它会在我们每次使用命令<code>hexo generate</code>后生成一系列文件，用于存储生成的一系列静态网页。hexo在生成网页时，会将你的Markdown文章和主题模板转换成HTML文件，并将这些生成的文件保存在<code>public</code>文件夹中。</p>
<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h4><p>这是 Hexo 的插件配置文件，也位于博客根目录下。它定义了博客所使用的插件及其版本信息。当你安装或更新插件时，<code>package.json</code> 文件会被相应地更新。可以通过命令行运行 <code>npm install</code> 来安装 <code>package.json</code> 中定义的插件。</p>
<h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a><code>themes</code></h4><p>这个是存放主题的文件夹，通过在<code>_config.yml</code>文件中修改主题的配置即可切换主题。</p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>我个人使用的主题是<code>butterfly</code>，它有较为完整的<a href="[Butterfly 安裝文檔(一">文档</a> 快速開始 | Butterfly](<a href="https://butterfly.js.org/posts/21cfbf15/))。">https://butterfly.js.org/posts/21cfbf15/))。</a></p>
<blockquote>
<p>在 hexo 的根目录创建一个文件<code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复制到 <code>_config.butterfly.yml</code>去，以后就只需要在<code>_config.butterfly.yml</code>中配置即可，原来的<code>_config.yml</code>就会失效。</p>
</blockquote>
<h3 id="文章框架"><a href="#文章框架" class="headerlink" title="文章框架"></a>文章框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line">XXX文章内容</span><br></pre></td></tr></table></figure>
<p>在文章的开头会预定义一些参数，如title定义标题，标定文章的标题，有一些标签需要特别注意，在这里我讲解一下。</p>
<h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><p>在这里引用一下官方原文，讲解的很清晰。</p>
<blockquote>
<p>官方原话：</p>
<p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p>
</blockquote>
<p>定义的格式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>
<p>这样的定义代表了这篇文章的分类属于<code>Diary</code>，并且有两个标签<code>PS3</code>和<code>Games</code>。</p>
<p>如果这样定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure>
<p>就会使得<code>Life</code>称为<code>Diary</code>的子分类，而不是并列分类。如果需要添加并列分类，是这样的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>
<p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>1123.最深叶节点的最近公共祖先</title>
    <url>/2023/09/06/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="1123-最深叶节点的最近公共祖先"><a href="#1123-最深叶节点的最近公共祖先" class="headerlink" title="1123. 最深叶节点的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/">1123. 最深叶节点的最近公共祖先</a></h2><p><img src="/images/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20230906110858312.png" alt="image-20230906110858312"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        题目给定三个条件：</p>
<ol>
<li>树中的节点数将在[1, 1000]的范围以内。</li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
<li>每个节点的值都是独一无二的。</li>
</ol>
<p>​        读题，如果只有一个最深叶节点，那么它本身就是它的最深叶节点。如果有两个最深叶节点，我们就应该找到一个节点，使之这两个叶节点能够存在与这两个节点的左右子树中。</p>
<p>​        注意到题目的节点数最大不过为1000，因此即便使用$O(n^2)$的算法也不会超时。</p>
<p>​        可以先遍历一遍二叉树，找到二叉树的最大深度，记为<code>max_depth</code>，再遍历一遍二叉树，判断某个节点的左右子树是否包含这个最深节点，即<code>if node1(depth==max_depth) in root-&gt;left and node2(depth==max_depth) in root-&gt;right</code>，且最好是从下往上去找，因为节点的值都是独一无二的，<strong>我们可以记录每一条到达二叉树的最深节点的路径，根据值的相等与否就能找到相应的祖先。如果路径数为1，那么就返回它本身，它本身就是最深节点的公共祖先。</strong></p>
<p>举几个例子，图中到达最深节点的路径有两条：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3, 5, 2, 7] 和 [3, 5, 2, 4]，其中2是离他们最近的公共祖先。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对[0, 1, 3, null, 2]这颗二叉树，到达最深节点的路径有一条：</span><br><span class="line"></span><br><span class="line">[0, 1, 2]，那么2就是离它最近的公共祖先。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对[1, 2, 3, 4, 5, 6, 7, null, null, 8, null, 9, 10, 11, 12]这颗二叉树，到达最深节点的路径有五条：</span><br><span class="line"></span><br><span class="line">[1, 2, 4, 8]</span><br><span class="line"></span><br><span class="line">[1, 2, 5, 9]</span><br><span class="line"></span><br><span class="line">[1, 2, 5, 10]</span><br><span class="line"></span><br><span class="line">[1, 3, 6, 11]</span><br><span class="line"></span><br><span class="line">[1, 3, 6, 12]</span><br></pre></td></tr></table></figure>
<p>要找它们的最近公共祖先，就是它们几个中相等值的最后一位，记为<code>parent</code>。</p>
<p>最后遍历一遍二叉树，<code>node-&gt;val == parent</code>就是我们要的那个节点。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先取到二叉树的最大深度</span></span><br><span class="line">        <span class="type">int</span> max_depth = <span class="built_in">depth</span>(root, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; max_depth &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取遍历到最大深度的路径</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">dp_path</span>(root, path, res, max_depth);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历最大路径，找到相等的值中最后一个</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = res[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            num = res[<span class="number">0</span>][i]; <span class="comment">// 先记录某一个可能的值，再进行接下来的遍历。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j][i] != num)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到节点对应的值之后，找到对应的节点</span></span><br><span class="line">        TreeNode* node = <span class="built_in">dfs</span>(root, num);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* root, <span class="type">int</span> dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left, dp), <span class="built_in">depth</span>(root-&gt;right, dp));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dp_path</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; path, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res, <span class="type">int</span> max_depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == max_depth)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dp_path</span>(root-&gt;left, path, res, max_depth);</span><br><span class="line">        <span class="built_in">dp_path</span>(root-&gt;right, path, res, max_depth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == num)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* l = <span class="built_in">dfs</span>(root-&gt;left, num);</span><br><span class="line">        TreeNode* r = <span class="built_in">dfs</span>(root-&gt;right, num);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2023/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>​        本篇文章将持续记录刷题过程中常见的数据结构与基本操作。</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算是一种对二进制数进行操作的运算。在计算机中，所有的数据都是以二进制形式存储的，位运算可以直接对二进制数的每一位进行操作，因此在一些场合下，位运算比其他运算更加高效。</p>
<p>对于一个数组<code>&#123;0, 2, 3&#125;</code>，我们可以存储一个二进制数，对应下标的数如果存在，则二进制该位为1，否则为0，比如说<code>0</code>在该数组中，那么该二进制数的<code>0</code>位就为1，按照<strong>从低位到高位</strong>依次类推，我们可以用<code>1101</code>表示数组<code>&#123;0,2,3&#125;</code>；再举个例子，比如说<code>&#123;1,2,3&#125;</code>可以用二进制数<code>1110</code>来表示。</p>
<h2 id="位运算在集合方面的应用"><a href="#位运算在集合方面的应用" class="headerlink" title="位运算在集合方面的应用"></a>位运算在集合方面的应用</h2><p>了解了位运算的基本概念之后，我们可以尝试在模拟一些集合的操作。</p>
<p>{1, 2, 3, 5, 7} {0, 2, 4, 5 ,7}</p>
<ol>
<li>对于求交集的操作</li>
</ol>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>​        哈希表（Hash table），国内也有一些算法的书籍称它为散列表，<strong>一般哈希表都是用来快速判断一个元素是否出现在集合里</strong>。</p>
<blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
</blockquote>
<p>​        将关键码和值对应的过程就叫做哈希映射，这其中涉及到了hash function， 也就是哈希函数。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>​        哈希函数通过<code>hashCode</code>将名字转化为数值，映射到哈希表上的索引数字。进行取模的操作防止索引数字超过了<code>tableSize</code>。但是这避免不了有几位学生的名字同时映射到了同一个索引下标的位置，因此引入了哈希碰撞。</p>
<h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223821997.png" alt="image-20230905223821997">        </p>
<p>​        如图，小李和小王都映射到了索引下标为1的位置，<strong>这一现象叫做哈希碰撞</strong>。</p>
<p>​        一般对于哈希碰撞，有两种解决方法，拉链法和线性探测法。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223859549.png" alt="image-20230905223859549"></p>
<p>​        </p>
<p>（数据规模为<code>dataSize</code>，哈希表的大小为<code>tableSize</code>）        </p>
<p>发生冲突的位置用链表去存储，这样就可以通过索引找到小李和小王了。</p>
<h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>如果使用线性探测法，一定要保证<code>tableSize&gt;dataSize</code>。我们需要依靠哈希表中的空位来解决碰撞问题。</p>
<p>即如果1存放了小李，下次小王又需要在1中存储时，那么小王会被放在了2的位置。所以要求<code>tableSize&gt;dataSize</code>，不然就没有空位来存放冲突的数据了。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223906320.png" alt="image-20230905223906320"></p>
<h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p>当我们遇到需要使用哈希法来解决问题的时候，我们一般会选择如下的三种数据结构。</p>
<ul>
<li>数组</li>
<li>set（集合）</li>
<li>map（映射）</li>
</ul>
<p>其上的几个例子就是数组的代表，我们重点关注一下set。</p>
<p>在C++中，set和map分别提供了以下三种数据结构，其底层实现以及优劣如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<p><code>std::unordered_set</code>底层实现为哈希表，<code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，<strong>红黑树是一种平衡二叉搜索树</strong>，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td style="text-align:left">std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td style="text-align:left">std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<p><code>std::unordered_map</code>底层实现为哈希表，<code>std::map</code> 和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用<code>unordered_set</code>，因为它的<strong>查询和增删效率是最优的</strong>，如果需要集合是有序的，那么就用<code>set</code>，如果要求不仅有序还要有重复数据的话，那么就用<code>multiset</code>。</p>
<p>那么再来看一下<code>map</code> ，在<code>map</code>是一个<code>key-value</code>的数据结构，<code>map</code>中，对<code>key</code>是有限制，对<code>value</code>没有限制的，因为key的存储方式使用红黑树实现的。</p>
<p>其他语言例如：<code>java</code>里的<code>HashMap</code>，<code>TreeMap</code> 都是一样的原理。可以灵活贯通。</p>
<p>虽然<code>std::set</code>、<code>std::multiset</code>的底层实现是红黑树，不是哈希表，<code>std::set</code>、<code>std::multiset</code>使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即<code>key</code>和<code>value</code>。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。<code>map</code>也是一样的道理。</p>
<p>这里在说一下，一些C++的经典书籍上 例如<code>STL</code>源码剖析，说到了<code>hash_set hash_map</code>，这个与<code>unordered_set</code>，<code>unordered_map</code>又有什么关系呢？</p>
<p>实际上功能都是一样一样的， 但是<code>unordered_set</code>在C++11的时候被引入标准库了，而<code>hash_set</code>并没有，所以建议还是使用<code>unordered_set</code>比较好，这就好比一个是官方认证的，<code>hash_set</code>，<code>hash_map</code>是C++11标准之前民间高手自发造的轮子。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230906223917132.png" alt="image-20230906223917132"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建-hexo</title>
    <url>/2023/09/05/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><p><strong>前置知识：</strong></p>
<ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript、jQuery</li>
</ul>
<p><strong>快速建站教程</strong></p>
<p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">Hexo-零基础搭建个人博客(详解)</a></p>
<p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210806984-1694011364573-1.png" alt="image-20230905210806984"></p>
<p><strong>推送至gitee仓库</strong></p>
<p>_config.yml文件中进行如下的修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://gitee.com/zzr-rr/zzr-rr.gitee.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>在执行推送命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">推送命令</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展：</p>
<p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p>
</blockquote>
<p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210828138.png" alt="image-20230905210828138">推送完成的界面。</p>
<p>由于gitee有一堆显示，我将他连接到github，并且部署到我的仓库。</p>
<p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210856266.png" alt="image-20230905210856266"></p>
<p>了解一下hexo吧，hexo的基本配置 <code>.config.yaml</code>文件下的各种参数</p>
<p><strong>网站</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>title</code></td>
<td>网站标题</td>
</tr>
<tr>
<td><code>subtitle</code></td>
<td>网站副标题</td>
</tr>
<tr>
<td><code>description</code></td>
<td>网站描述</td>
</tr>
<tr>
<td><code>author</code></td>
<td>您的名字</td>
</tr>
<tr>
<td><code>language</code></td>
<td>网站使用的语言</td>
</tr>
<tr>
<td><code>timezone</code></td>
<td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>网址</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td>网址</td>
</tr>
<tr>
<td><code>root</code></td>
<td>网站根目录</td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td>
</tr>
<tr>
<td><code>permalink_defaults</code></td>
<td>永久链接中各部分的默认值</td>
</tr>
</tbody>
</table>
</div>
<p><strong>如何对hexo网站进行修改，参考hexo的官方文档</strong></p>
<p><a href="https://hexo.io/zh-cn/api/">API | Hexo</a></p>
<h3 id="在git过程中遇到的一些问题"><a href="#在git过程中遇到的一些问题" class="headerlink" title="在git过程中遇到的一些问题"></a>在git过程中遇到的一些问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/Zzr-rr/Zzr-rr.github.io.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>
<p>打开<code>git bash</code>，解除SSL认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>
<p>git可能隔一段时间就会出现这个问题，及时修改即可。</p>
<p>因为是国外的网站，github经常连接超时，隔一段时间试试。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>630. 课程表III</title>
    <url>/2023/09/11/2023-9-11-630.-%E8%AF%BE%E7%A8%8B%E8%A1%A8III/</url>
    <content><![CDATA[<h1 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><a href="https://leetcode.cn/problems/course-schedule-iii/">630. 课程表 III</a></h1><p><img src="/images/2023-9-11-630.-课程表III/image-20230911135329512.png" alt="image-20230911135329512"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        这道题目我学习了<a href="[630. 课程表 III - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iii/solutions/1155605/ke-cheng-biao-iii-by-leetcode-solution-yoyz/">官方题解</a>)，简单说一下思路，方法是<strong>优先队列+贪心</strong>，修课程应该先从截止时间短的课程开始修，如果修不了也应该尽可能是该截止时间段内修了同等数目的课程中耗时最少的一种（因此使用了优先队列的数据结构，其实就是大根堆），具体的证明过程可以看看官方题解。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scheduleCourse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(courses.<span class="built_in">begin</span>(),courses.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; c0, <span class="type">const</span> <span class="keyword">auto</span>&amp; c1)&#123;</span><br><span class="line">            <span class="keyword">return</span> c0[<span class="number">1</span>] &lt; c1[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 优先队列中所有课程的总时间</span></span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; course:courses)&#123;</span><br><span class="line">            <span class="type">int</span> ti = course[<span class="number">0</span>], di =course[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(total + ti &lt;= di)&#123;</span><br><span class="line">                total += ti;</span><br><span class="line">                q.<span class="built_in">push</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>() &gt; ti)&#123;</span><br><span class="line">                total -= q.<span class="built_in">top</span>() - ti;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>207. 课程表</title>
    <url>/2023/09/09/2023-9-9-207.-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h1 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h1><p><img src="/images/2023-9-9-207.-课程表/image-20230909204417291.png" alt="image-20230909204417291"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        这道题目实际上就是一个找环的过程，构造一个有向图，以课程作为节点，以课程之间的先修关系作为有向箭头，课程之间如果不能修完，那么找它的先修课程一定会在某一个节点找到它自己。</p>
<p>​        换种思路看，如果课程的入度为0，代表着它之前没有先修课程，也就能直接学习，学习完这门课之后可以将这门课从图中删去，会解锁新的一批可以修的课（即入度为0的节点）。这样我们的基本思路就确定了：</p>
<ol>
<li>构造一个图（可以只构造每个节点的入度和出度）。</li>
<li>找到入度为0的点，如果没有，返回<code>false</code>。</li>
<li>在图中删去入度为0的点（即这门课解锁的课的入度减1）。</li>
<li>继续寻找入读为0的点，重复2，3步骤。</li>
<li>当所有的节点都被删除后，返回<code>true</code>。</li>
</ol>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>2594. 修车的最少时间</title>
    <url>/2023/09/06/2023-9-6-2594.-%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="2594-修车的最少时间"><a href="#2594-修车的最少时间" class="headerlink" title="2594. 修车的最少时间"></a><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/">2594. 修车的最少时间</a></h2><p><img src="/images/2023-9-6-2594.-修车的最少时间/image-20230907141918821.png" alt="image-20230907141918821"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>​        题目给定能力值为$r$的工人可以在$ r * n ^ 2 $时间内修完<script type="math/tex">n</script>辆车，也就是说一个如果给定一个时间$t$，那么在该时间内能够修完的车的数量应该为$\lfloor\sqrt{\frac{t}{r}}\rfloor$，那么$n$个工人能够修好的车辆总数$num$就是</p>
<script type="math/tex; mode=display">
num=\sum_{i=1}^{m}\lfloor\sqrt{\frac{t}{r_i}}\rfloor</script><p>我们注意到，这个$num$根据$t$的变化而在不断地增大。</p>
<p>我们就是要找到能够使得这个$num$值大于车辆的总数$n$的$t$值，这样所有的车就修好了。</p>
<p>每尝试一个$t$值，我们就需要计算一遍$num$，如果$t$按从小到大去遍历的话，对于$10^5$的数据量，这样的时间复杂度一定是超时的。</p>
<p>对于一个$t$值，任意大于等于这个$t$的数字我们都可以修好车，而小于$t$的数字我们都修不好车，不禁让我们联想到二分的方法去找到这一个$t$值，同时我们可以定义一个上界是第一位师傅修好车所需要的时间。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>能力值相同的人，在$t$时间内修好的车的个数是相等的。</p>
<p>根据数据范围，$ranks$中至多有100个不同的数字，我们可以统计$ ranks $中每个数字的出现次数，这样每次二分至多循环100次。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">num</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">long</span> <span class="type">long</span> t)</span></span>&#123;   <span class="comment">// 计算能修车的数量.</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ranks.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums += <span class="built_in">pow</span>(t/ranks[i], <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> right = <span class="type">long</span> <span class="built_in">long</span>(ranks[<span class="number">0</span>]) * <span class="type">long</span> <span class="built_in">long</span> (cars * cars); <span class="comment">// 第一位师傅修好车需要的时间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (right - left) &gt;&gt; <span class="number">1</span> + left; <span class="comment">// 这样定义mid是防止C++数组越界，这里的mid就代表着时间。</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;mid = &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;num(ranks, mid) = &quot;</span> &lt;&lt; <span class="built_in">num</span>(ranks, mid) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">num</span>(ranks, mid) &gt;= cars &amp;&amp; <span class="built_in">num</span>(ranks, mid - <span class="number">1</span>) &lt; cars)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span>(ranks, mid) &lt; cars)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span>(ranks, mid) &gt;= cars)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_r = ranks[<span class="number">0</span>], cnt[<span class="number">101</span>]&#123;&#125;; <span class="comment">// 数组比哈希表更快</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r : ranks) &#123;</span><br><span class="line">            min_r = <span class="built_in">min</span>(min_r, r);</span><br><span class="line">            cnt[r]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">1LL</span> * min_r * cars * cars;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (left + right) / <span class="number">2</span>, s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = min_r; r &lt;= <span class="number">100</span> &amp;&amp; s &lt; cars; r++) <span class="comment">// 至多循环 100 次</span></span><br><span class="line">                s += (<span class="type">long</span> <span class="type">long</span>) <span class="built_in">sqrt</span>(mid / r) * cnt[r];</span><br><span class="line">            (s &gt;= cars ? right : left) = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++常见考点</title>
    <url>/2023/09/07/C++/</url>
    <content><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>float 默认是双精度浮点型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> x;</span><br><span class="line">xf = <span class="number">123.1</span>; <span class="comment">// 在变量之后加f，可以变成单精度浮点型</span></span><br></pre></td></tr></table></figure>
<p><strong>字符型</strong>常量标识符: <code>&#39; &#39;</code></p>
<p><strong>字符串</strong>常量标识符:<code>&quot; &quot;</code></p>
<p>实型常量就是浮点数，分为十进制小数形式和指数形式两种</p>
<p>小数形式3.可以表示3.0，.1415可以表示0.1415</p>
<p>C++把这种形式的浮点数按双精度常量处理，在内存中占8个字节，如果在实数的数字之后加字母F或者f，表示此数为单精度浮点数，如3.1415F占4个字节。如果加字母L或l，表示此数为长双精度数（long double）。在VC++6.0中占8个字节。</p>
<p>实型常量的质素和形式一般为</p>
<p><code>&lt;数符&gt;数字部分E指数部分</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 3.1415e0;</span><br><span class="line"></span><br><span class="line">b = 0.314.15e1;</span><br></pre></td></tr></table></figure>
<p><strong>字符的表示</strong></p>
<p>用一对单括号括起来的一个字符就是字符型常量，如<code>&#39;a&#39;,&#39;A&#39;,&#39;@&#39;,&#39;9&#39;</code>都是合法的字符串常量。</p>
<p>字符常量在内存中占一个字节。</p>
<p>由于C++将大写字母和小写字母作为不同的符号处理，因此<code>&#39;a&#39;和‘A’</code>的ASCII码值不同。</p>
<p>C++对一些特殊的字符，提供了特殊的表示方法，即通过转义字符来表示。转义字符表示法<strong>是在一对单撇号里加上以\开头的若干个字符，用以表示特定的字符</strong>。</p>
<p><strong>转义字符</strong>只代表一个字符，在内存中只占一个字节。</p>
<p>如<code>&#39;\a&#39;</code>表示一个警报声，会发出一个特殊的声音。</p>
<p>输出单个单引号<code>&#39;\&#39;&#39;</code></p>
<p>输出一个反斜杠<code>&#39;\\&#39;</code></p>
<p>空字符（’\0’）对应的ASCII码值是0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">i = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">j = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl; <span class="comment">// 输出的是65和66</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> i, j;</span><br><span class="line">i = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">j = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl</span><br></pre></td></tr></table></figure>
<p>字符串的结尾处添加一个空字符’\0’，用于标识一个字符串的终结。</p>
<p>因此，保存的空间至少是字符串的长度+1。</p>
<p><strong>符号常量与常变量</strong></p>
<p>利用预处理宏替换指令对<strong>符号常量</strong>进行说明的形式为：</p>
<p><code>#define</code></p>
<p>例如 <code>#define PI 3.1415</code></p>
<p><strong>变量的名字</strong></p>
<ol>
<li>见名知义</li>
<li>下划线或者字母开头</li>
</ol>
<p><strong>常变量</strong></p>
<p>用<code>const</code>定义的常变量，必须在定义的时候就给定确切的数值，并且在其后的程序中不能再改变数值。</p>
<p>常变量在定义的时候必须有初值，不能再赋值。</p>
<p>存储类型即为auto，register，static，extern中之一。</p>
<p>程序内共享的变量定义为static</p>
<p>程序间共享的变量定义为extern</p>
<p>在定义变量的时候，最好进行初始化，否则变量为一个随机值，后面进行操作时会出现问题。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61C</title>
    <url>/2023/09/10/2023-9-10-CS61C/</url>
    <content><![CDATA[<h1 id="CS61C"><a href="#CS61C" class="headerlink" title="CS61C"></a>CS61C</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processeors:处理器</span><br><span class="line">hard disk drives:硬盘驱动器</span><br><span class="line">Number Representation:数字表示法</span><br><span class="line">biased notation:移码</span><br><span class="line">bit overflows:位溢出</span><br><span class="line">sign extension:符号扩展</span><br><span class="line">one&#x27;s complement:补码</span><br><span class="line">two&#x27;s complement:二进制补码</span><br></pre></td></tr></table></figure>
<h2 id="Lecture-01"><a href="#Lecture-01" class="headerlink" title="Lecture 01"></a>Lecture 01</h2><h3 id="Number-Representation"><a href="#Number-Representation" class="headerlink" title="Number Representation"></a>Number Representation</h3><p>十进制，八进制，十六进制，二进制。</p>
<p>计算机采用二进制。</p>
<h4 id="Bits-are-Bits-Bits-can-represent-ANYTHING"><a href="#Bits-are-Bits-Bits-can-represent-ANYTHING" class="headerlink" title="Bits are Bits, Bits can represent ANYTHING"></a><strong>Bits are Bits, Bits can represent ANYTHING</strong></h4><ul>
<li><p>26 letters require 5 bits($2^5 = 32 &gt;26$)</p>
</li>
<li><p>upper/lower case + punctuation -&gt; 7 bits(“ASCII”)</p>
</li>
<li><p>true or false (0 or 1)</p>
</li>
<li><p>ONLY ONE constraint:</p>
<script type="math/tex; mode=display">n digsts(base B)   <= B^n things</script></li>
</ul>
<p>位数的增加可以增加能够表示的数据，表示负数可以用第一位符号位来表示正负号。</p>
<h4 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a><strong>Overflow</strong></h4><p>Overflow is when the result of an arithmetic operation can’t be represented by the (FINITE) hardware bits.</p>
<p>Examples:<br> — unsigned:  $0b1…1 + 1_{10} = 0b0…0 = 0?$</p>
<p> — Two’s:        $0b01…1+1<em>{10}=0b10…0=-(2^{n-1})</em>{ten}$</p>
<p><img src="/images/2023-9-10-CS61C/image-20230911101431619.png" alt="image-20230911101431619"></p>
<p>Solutions: add more bits</p>
<h4 id="Sign-Extension"><a href="#Sign-Extension" class="headerlink" title="Sign Extension"></a><strong>Sign Extension</strong></h4><p> — Sign and magnitude: $0b11=0b1001$</p>
<p> — One’s/Two’s complement: $0b11=0b1111$</p>
<h4 id="Conversions"><a href="#Conversions" class="headerlink" title="Conversions"></a><strong>Conversions</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th>$2^{10}$</th>
<th>$2^{20}$</th>
<th>$2^{30}$</th>
<th>$2^{40}$</th>
<th>$2^{50}$</th>
<th>$2^{60}$</th>
<th>$2^{70}$</th>
<th>$2^{80}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kibi</td>
<td>Mebi</td>
<td>GiBi</td>
<td>Tebi</td>
<td>Pebi</td>
<td>Exbi</td>
<td>Eebi</td>
<td>Yobi</td>
</tr>
</tbody>
</table>
</div>
<p>移位不能改变位数能表示的距离，只是范围的移动，范围的大小并不改变。</p>
<p>对于<code>2&#39;s complement</code></p>
<p><code>overflow</code>的情况只存在于正的加正的，负的加负的。</p>
<h2 id="Lecture-02"><a href="#Lecture-02" class="headerlink" title="Lecture 02"></a>Lecture 02</h2><h3 id="Variable-Types"><a href="#Variable-Types" class="headerlink" title="Variable Types"></a>Variable Types</h3><p><strong>Interget sizes are machinne dependant</strong></p>
<p>  — Common size is 4 or 8 bytes(32/64-bit)</p>
<p>C must manage your memory carefully(like use ‘malloc’ and ‘free’)</p>
<h4 id="Syntax-and-Control-Flow"><a href="#Syntax-and-Control-Flow" class="headerlink" title="Syntax and Control Flow"></a>Syntax and Control Flow</h4><p><strong>Generic C Program Layout</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_files&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;local_files&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> macro_name macro_expr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* declare functions */</span></span><br><span class="line"><span class="comment">/* decalre global variables and structs */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span>&#123;</span><br><span class="line">	<span class="comment">/* the innards */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* define other funcitons */</span></span><br></pre></td></tr></table></figure>
<p><strong>A variable may be initialized in its declaration;if not, it holds garbage!</strong></p>
<p>C语言不像java和其他语言，没有true或者false。</p>
<h4 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h4><ul>
<li><p>Consider the memory as a single huge array. Each cell of the array has its own address.(like dictionary, the address is the key, the value is a value).</p>
</li>
<li><p><strong>Don’t confuse the address referring to a memory location with the value stored there</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *x;</span><br><span class="line"> - 声明一个variable x 为 address of an int</span><br><span class="line">x = &amp;y;</span><br><span class="line"> - x 赋值address of y</span><br><span class="line">z = *x;</span><br><span class="line"> - z 赋值地址x所指向的那个值</span><br></pre></td></tr></table></figure>
<p>void * 可以指向任何事(generic pointer)。(Use sparingly to help avoid program bugs and other bad things)</p>
<ul>
<li><code>*</code>的位置对于编译器来说没有影响<br><code>int* x</code> is the same as <code>int *x</code></li>
<li><code>int *x, y, z</code> is the same as <code>int* x,y,z</code>;but NOT the same as <code>int *x, *y, *z</code>;</li>
</ul>
<p><strong>Pointer Bugs</strong></p>
<ul>
<li>C中的局部变量不被初始化，它们可以包含任何事(a.k.a “garbage”)</li>
<li>声明一个指针仅仅是allocates space to hold the pointer —— 它并没有分配任何被指向的东西。</li>
</ul>
<p>bad示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p, x;</span><br><span class="line">	x = *p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p没有指向任何，很可能是个垃圾</span></span><br></pre></td></tr></table></figure>
<h2 id="Lecture-03"><a href="#Lecture-03" class="headerlink" title="Lecture 03"></a>Lecture 03</h2><h3 id="Struct-Clarification"><a href="#Struct-Clarification" class="headerlink" title="Struct Clarification"></a>Struct Clarification</h3><p>Joint struct definition and typedef</p>
<p> — Don’t need to name struct in this case</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line">	<span class="comment">/* fields */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">bar</span>;</span></span><br><span class="line">bar name1;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line">	<span class="comment">/* fields */</span></span><br><span class="line">&#125;bar;</span><br><span class="line">bar name1;</span><br></pre></td></tr></table></figure>
<h3 id="C-operators"><a href="#C-operators" class="headerlink" title="C operators"></a>C operators</h3><p><strong>Operator Precedence</strong></p>
<ul>
<li>Use parenthese sotmanipulate</li>
<li>Equality test (==) binds more tightly than logic(&amp;,|,&amp;&amp;,||)<br><strong>— x &amp; 1 == 0 means x&amp;(1 == 0) instead of (x&amp;1)  == 0</strong></li>
</ul>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a><strong>Arrays</strong></h3><p><img src="/images/2023-9-10-CS61C/image-20230913152215530.png" alt="image-20230913152215530"></p>
<p>结构体通过不同的排序方式进行存储，能够达到节省空间的效果。（adjust the order of the elements）</p>
<p>declare array时，初始化长度最好使用const变量</p>
<ul>
<li><p>ar[i] is treatd as *(ar + i)</p>
</li>
<li><p>To zero the array, the following three ways are equivalent:</p>
<ol>
<li><p>```C<br>for(int i = 0; i &lt; SIZE; i++){ar[i] = 0;}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">   for(int i = 0; i &lt; SIZE; I++)&#123;*(ar + i) = 0;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="lang-c">for(p = ar; p &lt; ar.SIZE(); p++)&#123;*p = 0;&#125;
</code></pre>
</li>
</ol>
</li>
<li><p>These use pointer arithmetic. </p>
</li>
</ul>
<p>Array’s name is not a varible but a pointer  </p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      <categories>
        <category>课程</category>
        <category>CS61C</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>CS61C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++常见基本操作</title>
    <url>/2023/09/10/C++%20%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="C-常见基本操作"><a href="#C-常见基本操作" class="headerlink" title="C++ 常见基本操作"></a>C++ 常见基本操作</h1><h2 id="一-unordered-set"><a href="#一-unordered-set" class="headerlink" title="一. unordered_set"></a>一. unordered_set</h2><h3 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a><strong>引入头文件</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>​        我们可以简单地将unordered_set理解为一个无序的集合，它的底层实现是哈希表，且拥有较高的查询效率和增删效率，一般我们可以用这个数据结构判断某个元素是否已经遍历过。</p>
<blockquote>
<p>三个特性：</p>
<ol>
<li>无序</li>
<li>不以键值对的方式存储</li>
<li>不重复</li>
</ol>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p><strong>创建空set</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; set1;</span><br></pre></td></tr></table></figure>
<p><strong>拷贝构造</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set2</span><span class="params">(set1)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用迭代器构造</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set3</span><span class="params">(set1.begin(), set1.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用数组作为其初值进行构造</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set4</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>移动构造</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set5</span><span class="params">(move(set2))</span></span>;</span><br></pre></td></tr></table></figure>
<p>在这里解释以下什么是移动构造，<strong>移动构造是C++11标准中提供的一种新的构造方法。</strong></p>
<p>引用以下吾爱技术圈的例子。</p>
<blockquote>
<p>先举个生活例子，你有一本书，你不想看，但我很想看，那么我有哪些方法可以让我能看这本书？有两种做法，一种是你直接把书交给我，另一种是我去买一些稿纸来，然后照着你这本书一字一句抄到稿纸上。</p>
<p>显然，第二种方法很浪费时间，但这正是有些深拷贝构造函数的做法，而移动构造函数便能像第一种做法一样省时，第一种做法在 C++ 中叫做完美转发。</p>
<p>在C++11之前，如果要将源对象的状态转移到目标对象只能通过复制。<br>而现在在某些情况下，我们没有必要复制对象，只需要移动它们。</p>
<p>C++11引入移动语义：<br>源对象资源的控制权全部交给目标对象。</p>
</blockquote>
<p>复制构造和拷贝构造对比：</p>
<p><img src="/images/C++ 常见基本操作/image-20230910095602575.png" alt="image-20230910095602575"></p>
<p><strong>使用初值列表进行构造</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; set6 &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unordered-set的常用内置函数"><a href="#unordered-set的常用内置函数" class="headerlink" title="unordered_set的常用内置函数"></a>unordered_set的常用内置函数</h3><p><strong>empty()函数——判断是否为空</strong></p>
<p>空返回true，非空返回false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set1.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>
<p><strong>find()函数——查找</strong></p>
<p>找到了返回迭代器；找不到返回end()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set1.<span class="built_in">find</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>count()函数——出现次数</strong></p>
<p>返回某个值出现的次数，可以用来判断某个值是否存在于某个数组中</p>
<p>，由于unordered_set是无序的，因此一个元素出现的次数至多为1，count()函数的返回值是0或1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set1.<span class="built_in">count</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>关于insert的返回值：</strong></p>
<p><strong>insert()只传入单个参数（待插入元素）</strong></p>
<blockquote>
<ol>
<li>可以用一个迭代器作为insert()的第一个参数，它指定了元素被插入的位置</li>
<li>在这种情况下，只会返回一个迭代器</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = words.<span class="built_in">insert</span>(pr.first, <span class="string">&quot;nine&quot;</span>); <span class="comment">// 1st arg is a hint. Returns an iterator</span></span><br></pre></td></tr></table></figure>
<p><strong>erase()函数——删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除元素，成功返回1，失败返回0</span></span><br><span class="line">set1.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 删除操作，成功返回下一个pair的迭代器</span></span><br><span class="line">set1.<span class="built_in">erase</span>(set1.<span class="built_in">find</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 删除set1的所有元素，返回指向end的迭代器</span></span><br><span class="line">set1.<span class="built_in">erase</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p><strong>清空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set1.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
<h2 id="二-queue"><a href="#二-queue" class="headerlink" title="二. queue"></a>二. queue</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>queue是一种容器转换模板，调用<code>#include &lt;queue&gt;</code>即可使用队列类。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>```c++<br>queue<int>q1;<br>queue<double>q2;<br>queue＜char＞q3；<br>//默认为用deque容器实现的queue；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c++</span><br><span class="line">   queue＜char, list＜char＞＞q1；</span><br><span class="line">   //用list容器实现的queue </span><br><span class="line">   </span><br><span class="line">   queue＜int, deque＜int＞＞q2；</span><br><span class="line">    //用deque容器实现的queue </span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意：不能用vector容器初始化queue</strong></p>
<p>因为queue转换器要求容器支持<code>front(), back(), push_back(), pop_left()</code>，说明queue的数据从容器后端入栈而从前端出栈。所以可以使用<code>deque</code>和<code>list</code>对<code>queue</code>进行初始化，而<code>vector</code>因其缺少<code>pop_left()</code>，不能用于<code>queue</code>。</p>
<p><strong>常用操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. push() 在队尾插入一个元素</span><br><span class="line">2. pop() 删除队列第一个元素</span><br><span class="line">3. size() 返回队列中元素个数</span><br><span class="line">4. empty() 如果队列空则返回true</span><br><span class="line">5. front() 返回队列中的第一个元素</span><br><span class="line">6. back() 返回队列中最后一个元素</span><br></pre></td></tr></table></figure>
<h2 id="三-C"><a href="#三-C" class="headerlink" title="三. C++ [](){}"></a>三. <code>C++ []()&#123;&#125;</code></h2><p>该形式是C++中的<strong>lamda函数</strong>（匿名函数）</p>
<p><strong>普通函数与lamda函数对比</strong></p>
<p>匿名函数是许多编程语言都支持的概念，有函数体，没有函数名。</p>
<p>函数对象能维护状态，但语法开销大，而函数指针语法开销小，却没法保存范围内的状态。</p>
<p><strong>基本lambda语法</strong></p>
<p>基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure>
<p>[]叫做捕获说明符，表示一个lambda表达式的开始。接下来是参数列表，即这个匿名的lambda函数的参数，-&gt;return-type表示返回类型，如果没有返回类型，则可以省略这部分的内容。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []()&#123;cout&lt;&lt;<span class="string">&quot;hello,world&quot;</span>;&#125;;</span><br><span class="line"><span class="built_in">func</span>(); <span class="comment">// now call the function</span></span><br></pre></td></tr></table></figure>
<p>变量捕获和lambda闭包实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">[&amp;]()&#123;cout &lt;&lt; name;&#125;();</span><br></pre></td></tr></table></figure>
<p>lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] 不截取任何变量</span><br><span class="line">[&amp;&#125; 截取外部作用域中所有变量，并作为引用在函数体中使用</span><br><span class="line">[=] 截取外部作用域中所有变量，并拷贝一份在函数体中使用</span><br><span class="line">[=, &amp;foo] 截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用</span><br><span class="line">[bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量</span><br><span class="line">[x, &amp;y] x按值传递，y按引用传递</span><br><span class="line">[this] 截取当前类中的this指针。如果已经使用了&amp;或者=就默认添加此选项。</span><br></pre></td></tr></table></figure>
<h2 id="四-sort"><a href="#四-sort" class="headerlink" title="四. sort"></a>四. sort</h2><p>​        <code>sort</code>是一个类似于快速排序的方法。<strong>时间复杂度是$O(nlog_2n)$，执行的效率相对来说还是比较高的。根据不同的数据量会选择不同的排序方式（结合插入排序和堆排序，根据不同的数量级别以及不同情况，能自动选用合适的排序方法）。</strong></p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>algorithm</code>是C++标准模板库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模板函数。</p>
<h3 id="sort（）基本使用方法"><a href="#sort（）基本使用方法" class="headerlink" title="sort（）基本使用方法"></a>sort（）基本使用方法</h3><p>​        <code>sort(begin, end, cmp)</code>是sort函数的基本使用方法。</p>
<p>​        <code>begin</code>是指向待排序的数组的<strong>第一个元素的指针</strong>。</p>
<p>​        <code>end</code>为指向<strong>最后一个元素的下一个位置的指针</strong>。</p>
<p>​        <code>cmp</code>为排序准则，<code>cmp</code>参数可以不写，如果不写的话，默认从小到大排序。如果我们想要从大到小排序，可以将<code>cmp</code>参数写为<code>greater&lt;int&gt;()</code>就是对int数组进行排序，当然<code>&lt;&gt;</code>中我们也可以写<code>double、long、float</code>等等。如果我们需要按照其它的排序准则，那么需要我们自己定义一个bool类型的函数来传入。</p>
<h2 id="五-map"><a href="#五-map" class="headerlink" title="五. map"></a>五. map</h2><p>C++ 的 <code>std::map</code> 是一个关联容器，它包含键值对，并且按键进行排序。<code>std::map</code> 允许基于键快速查找、添加和删除元素。下面是 <code>std::map</code> 的一些基本操作：</p>
<ol>
<li><strong>声明和初始化</strong>:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;  <span class="comment">// 创建一个从 int 到 string 的映射</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>插入元素</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;         <span class="comment">// 使用下标操作符插入或更新元素</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>)); <span class="comment">// 使用 insert 方法插入</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>查找元素</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="number">2</span>);  <span class="comment">// 返回指向键为2的元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;second;  <span class="comment">// 输出 &quot;two&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>遍历</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;pair : m) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>删除元素</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">// 删除键为2的元素</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>获取大小</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> size = m.<span class="built_in">size</span>(); <span class="comment">// 返回元素的数量</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>检查是否为空</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isEmpty = m.<span class="built_in">empty</span>(); <span class="comment">// 如果map为空，返回 true</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>清空 map</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">clear</span>(); <span class="comment">// 删除所有元素</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>访问元素</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string value = m[<span class="number">1</span>]; <span class="comment">// 使用下标操作符访问键为1的元素的值</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>其他操作</strong>：</li>
</ol>
<ul>
<li><code>m.count(key)</code>: 返回与给定键关联的元素数量，对于 map，结果是 0（不存在）或 1（存在）。</li>
<li><code>m.lower_bound(key)</code> 和 <code>m.upper_bound(key)</code>: 对于给定的键，返回相应的迭代器。特别是，<code>lower_bound</code> 返回指向不小于给定键的第一个元素的迭代器，而 <code>upper_bound</code> 返回指向大于给定键的第一个元素的迭代器。</li>
</ul>
<h2 id="六-C-常见刷题技巧"><a href="#六-C-常见刷题技巧" class="headerlink" title="六. C++常见刷题技巧"></a>六. C++常见刷题技巧</h2><p><a href="https://www.yuque.com/jackyao/ifeq8i/vyigt9?">C/C++刷题常用技巧 (yuque.com)</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1462. 课程表IV</title>
    <url>/2023/09/11/2023-9-11-1462.-%E8%AF%BE%E7%A8%8B%E8%A1%A8IV/</url>
    <content><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="1462-课程表-IV"><a href="#1462-课程表-IV" class="headerlink" title="1462. 课程表 IV"></a><a href="https://leetcode.cn/problems/course-schedule-iv/description/">1462. 课程表 IV</a></h2><p><img src="/images/2023-9-11-1462.-课程表IV/image-20230912122234846.png" alt="image-20230912122234846"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        这道题目的关键点也在于两种不同的搜索方式。BFS和DFS。</p>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>​        这道题要用到一个关键的排序方式，即拓扑排序。我们创建一个$numCourse×numCourse$的矩阵$isPre$，其中$isPre[x][y]$代表了课程x是否是课程y的直接或间接先决条件，若是则$isPre[x][y]=True$，若不是则$isPre[x][y]=False$。在构造完这个$isPre$数组之后，只需要$O(1)$的时间复杂度即可进行查询。</p>
<h4 id="BFS-剪枝"><a href="#BFS-剪枝" class="headerlink" title="BFS+剪枝"></a>BFS+剪枝</h4><p>​        广度优先搜索，我们直接模拟一下搜索的过程，比如我们需要查询课程1是否为课程5的先修课程，于是就可以从课程1出发，遍历所有修完课程1后可以修的课程，将这些课程加入队列中，再遍历队列中的每一个元素，和课程1按照同样的思路，将遍历到的元素修完之后所有可以修的课加入到队列当中，直到队列为空，队列为空之后，就返回<code>false</code>，如果在遍历的过程中找到了该节点，则返回<code>true</code>。</p>
<h4 id="DFS-拓扑排序"><a href="#DFS-拓扑排序" class="headerlink" title="DFS+拓扑排序"></a>DFS+拓扑排序</h4><p>深度优先搜索需要记录每一个点是否被访问，我们用$vi[x]$来表示课程x是否被访问，初始时为False。</p>
<p>我们从编号小到大遍历全部节点，若节点i未被访问，则进入DFS</p>
<ul>
<li>若当前节点x已被访问，则直接返回。</li>
<li>若当前节点x未被访问，将访问状态设置为已访问，然后继续对其全部后继节点递归进行DFS流程。将节点x置为其每一个后继节点y的先决条件，有$isPre[x][y]=True$，以及对于每一个y为先决条件的节点t，节点x同样为t的先决条件，有$isPre[x][t]=True$。</li>
</ul>
<p>遍历完成后，拓扑排序完成，矩阵$isPre$，然后我们遍历每一个查询，根据矩阵$isPre$即可得到每一个查询的结果。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="BFS-剪枝-1"><a href="#BFS-剪枝-1" class="headerlink" title="BFS+剪枝"></a>BFS+剪枝</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">      vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">      <span class="comment">// 初始化课程表的出度</span></span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">out</span>(numCourses);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;course: prerequisites)&#123;</span><br><span class="line">        out[course[<span class="number">0</span>]].<span class="built_in">push_back</span>(course[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遍历询问</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;query: queries)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bfs</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = query[<span class="number">1</span>];</span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(query[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(x == ans)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(bfs[x] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m: out[x])&#123;</span><br><span class="line">              <span class="keyword">if</span>(bfs[m] == <span class="number">1</span>)&#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              q.<span class="built_in">push</span>(m);</span><br><span class="line">            &#125;</span><br><span class="line">            bfs[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DFS-拓扑排序-1"><a href="#DFS-拓扑排序-1" class="headerlink" title="DFS+拓扑排序"></a>DFS+拓扑排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp; g, vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt;&amp; isPre, vector&lt;<span class="type">bool</span>&gt; &amp; vi, <span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vi[cur])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vi[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ne: g[cur])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(g, isPre, vi, ne);</span><br><span class="line">        isPre[cur][ne] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; isPre.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            isPre[cur][i] = isPre[cur][i] | isPre[ne][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个isPre数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">isPre</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (numCourses, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 创建vi数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vi</span><span class="params">(numCourses, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">g</span>(numCourses);</span><br><span class="line">        <span class="comment">// dfs需要的参数:</span></span><br><span class="line">        <span class="comment">// 1.isPre数组进行记录</span></span><br><span class="line">        <span class="comment">// 2.它的上一个节点</span></span><br><span class="line">        <span class="comment">// 3.一个visted数组，用来记录已经访问过的数字。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p:prerequisites)&#123;</span><br><span class="line">            g[p[<span class="number">0</span>]].<span class="built_in">push_back</span>(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; numCourses; i ++)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(g, isPre, vi, i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; query: queries)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(isPre[query[<span class="number">0</span>]][query[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>2596. 检查骑士巡视方案</title>
    <url>/2023/09/13/2023-9-13-2596.-%E6%A3%80%E6%9F%A5%E9%AA%91%E5%A3%AB%E5%B7%A1%E8%A7%86%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="2596-检查骑士巡视方案"><a href="#2596-检查骑士巡视方案" class="headerlink" title="2596. 检查骑士巡视方案"></a><a href="https://leetcode.cn/problems/check-knight-tour-configuration/description/">2596. 检查骑士巡视方案</a></h2><p><img src="/images/2023-9-13-2596.-检查骑士巡视方案/image-20230913120327599.png" alt="image-20230913120327599"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h4><p>​        题目给定了n的范围为[3, 7]，也就是如果采用$O(n^3)$的时间复杂度去计算，最多循环$7^6=117649$次，我们可以尝试遍历每一个值，并且通过循环的找到它的下一个位置，判断是否为合法的跳跃即可。</p>
<h4 id="DFS搜索"><a href="#DFS搜索" class="headerlink" title="DFS搜索"></a>DFS搜索</h4><p>​        题目是骑士在不断的跳跃，因此可以进行八方向模拟。判断好终止条件即可。终止条件：</p>
<ol>
<li>最后遍历到的数字为$n*n-1$。</li>
<li>遍历的次数为$n*n-1$。</li>
</ol>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="暴力搜索-1"><a href="#暴力搜索-1" class="headerlink" title="暴力搜索"></a>暴力搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">abs</span>(r - a) == <span class="number">2</span> &amp;&amp; <span class="built_in">abs</span>(c - b) == <span class="number">1</span>) || (<span class="built_in">abs</span>(r - a) == <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(c - b) == <span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidGrid</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0找到n*n-2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * n - <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 遍历数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; c++)&#123;</span><br><span class="line">                    <span class="comment">// 找到数组之后</span></span><br><span class="line">                    <span class="keyword">if</span>(grid[r][c] == i)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; n; a++)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; n; b++)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(grid[a][b] == i + <span class="number">1</span>)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(!<span class="built_in">legal</span>(r, c, a, b))&#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DFS搜索-1"><a href="#DFS搜索-1" class="headerlink" title="DFS搜索"></a>DFS搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp;grid, <span class="type">int</span> num,<span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() || c &lt; <span class="number">0</span> || c &gt;= grid.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] == grid.<span class="built_in">size</span>() * grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; num == grid.<span class="built_in">size</span>() * grid.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;r = &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot; c = &quot;</span> &lt;&lt; c;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">2</span>, c + <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">2</span>, c - <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">1</span>, c + <span class="number">2</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">1</span>, c - <span class="number">2</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">2</span>, c + <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">2</span>, c - <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">1</span>, c + <span class="number">2</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">1</span>, c - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidGrid</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>1222. 可以攻击国王的皇后</title>
    <url>/2023/09/14/2023-9-14-1222.-%E5%8F%AF%E4%BB%A5%E6%94%BB%E5%87%BB%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="1222-可以攻击国王的皇后"><a href="#1222-可以攻击国王的皇后" class="headerlink" title="1222. 可以攻击国王的皇后"></a><a href="https://leetcode.cn/problems/queens-that-can-attack-the-king/description/">1222. 可以攻击国王的皇后</a></h2><p><img src="/images/2023-9-14-1222.-可以攻击国王的皇后/image-20230914094038158.png" alt="image-20230914094038158"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>正难则反</strong></p>
<p>​        从Q去找K，有八条路，每个Q都需要找8个方向的同时还要确保路上不能有其它的Q，因此我们只需要从K出发找8个方向，如果这8个方向上有Q的话就直接返回，思路并不难。</p>
<p><strong>前置+和后置+</strong></p>
<p>​        这道题目涉及到了for循环，在这里一并解释下我困惑我已久的前置+和后置+</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br></pre></td></tr></table></figure>
<p>​        前置＋会比后置+拥有更高的效率，如图所示。</p>
<p><img src="/images/2023-9-14-1222.-可以攻击国王的皇后/image-20230914232359530.png" alt="image-20230914232359530"></p>
<p>​        不过对于整数的操作，编译器会进行优化，都为add1的操作。</p>
<p><img src="/images/2023-9-14-1222.-可以攻击国王的皇后/image-20230914232425999.png" alt="image-20230914232425999"></p>
<p><strong>事实上，后置递增内部需要一个临时对象，因为它必须要存放迭代器本来的位置并且返回之。</strong></p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; res, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> (&amp;arr)[<span class="number">8</span>][<span class="number">8</span>])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span> &amp;&amp; c== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">7</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt; &#123;x, y&#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x += r;</span><br><span class="line">            y += c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">queensAttacktheKing</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queens, vector&lt;<span class="type">int</span>&gt;&amp; king) &#123;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;queen:queens)&#123;</span><br><span class="line">            arr[queen[<span class="number">0</span>]][queen[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">search</span>(res, i, j, king[<span class="number">0</span>], king[<span class="number">1</span>], arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>198. 打家劫舍</title>
    <url>/2023/09/16/2023-9-16-198.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2><p><img src="/images/2023-9-16-198.-打家劫舍/image-20230916084001318.png" alt="image-20230916084001318"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        经典的动态规划，小偷可以从第一家走到最后一家，走到第三家的时候，有两种偷法，偷第一家和它的前两家或者偷第二家，在往后走，我们可以<strong>不断更新走到某一家的时候前$i$家能够偷到的最大金额</strong>，不断更新，在走到某一栋房屋$i$的时候，我们有如下的递推公式：</p>
<p>​                                        <script type="math/tex">dp[i] = max(dp[i-1] ,dp[i-2]+nums[i])</script></p>
<p>最后<code>dp</code>数组的最后一位就是所有房屋能够偷到的最大金额了。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>effective stl</title>
    <url>/2023/09/16/effective%20stl/</url>
    <content><![CDATA[<h2 id="effective-stl"><a href="#effective-stl" class="headerlink" title="effective stl"></a>effective stl</h2><h3 id="熟悉stl本身"><a href="#熟悉stl本身" class="headerlink" title="熟悉stl本身"></a>熟悉stl本身</h3><ul>
<li>慎重选择stl容器，每一种stl容器对应不同的使用场景，比如deque<bool>往往比vector<bool>更加合适</li>
<li>封装stl容器，积极的使用stl，可以高效的使用它</li>
<li>积极使用其对应迭代器使用的函数，比如做相加运算使用accumulate替代for循环，可以更加高效</li>
<li>调用对应的函数的时候，不使用过于复杂的名称，防止C++编译机制出现错误</li>
<li>STL并非线程安全的。它不支持并发的写入。所以在写入之前记得上锁</li>
<li>区别相等与等价：相等指的是里里外外完全相同，等价指的是可能只是外表相同</li>
<li><h1 id="include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心"><a href="#include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心" class="headerlink" title="include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心"></a>include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心</h1></li>
<li>当查询的操作和删除的操作几乎不混在一起的时候，排序的vector会比关联容器更好</li>
<li>不去修改set/mutiset的吉安，修改他们可能会导致位置的行为</li>
<li>string的实现的多种多样，所以对应的大小也不是一样的</li>
</ul>
<h3 id="熟悉stl函数"><a href="#熟悉stl函数" class="headerlink" title="熟悉stl函数"></a>熟悉stl函数</h3><ul>
<li>调用empty而不是size。因为empty始终是常数时间。而size有些时候则是on</li>
<li>对于常见非关联容器，remove/remove-if和erase都是常见的删除用法，他能保证删除元素的同时改变容器大小。list使用remove，关联容器直接使用erase</li>
<li>对于已知容器的大小，可以使用reserve减少string/vector类容器增长所需要的时间，减少不必要的分配</li>
<li>使用swap函数对vector和string快速的放空有奇效，而且速度很快</li>
<li>编写比较函数的时候，我们不仅要保证operator&lt;和less<T>要具有相同的意思，还更要保证要在等值的情况下返回false，保证一个严格的弱序化</li>
<li>对于逐个字符的输入，可以使用istreambuf-iterator</li>
<li>确保使用函数的时候，目标区间足够大，否则会导致一些未知的函数</li>
<li>熟悉常见的排序函数，包括sort，patition等函数</li>
<li>容器的成员函数优先于同名算法</li>
<li>确保判别式是纯函数。考虑函数对象而不是函数作为stl算法的参数</li>
</ul>
<h3 id="熟悉STL容器内部的对象"><a href="#熟悉STL容器内部的对象" class="headerlink" title="熟悉STL容器内部的对象"></a>熟悉STL容器内部的对象</h3><ul>
<li>确保容器中的对象能高效的拷贝且正确。完整区分开深拷贝和浅拷贝</li>
<li>对于容器中包括了纯指针，记得要在容器对象析构前挨个delete指针。或者使用share-ptr。当然还有remove-erase也是一样</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>213. House Robber II</title>
    <url>/2023/09/17/2023-9-17-213.-House-Robber-II/</url>
    <content><![CDATA[<h2 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h2><h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213.  House Robber II"></a><a href="https://leetcode.cn/problems/house-robber-ii/description/">213.  House Robber II</a></h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/images/2023-9-17-213.-House-Robber-II/image-20230917112812696.png" alt="image-20230917112812696"></h3><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        和打家劫舍I不同的是，这个房子是首尾相连的，依旧是动态规划。问题的主要在于如何处理首尾的房子，有两种不同的方式，首房子可以访问，尾部房子不能访问；首房子不可以访问，尾部房子可以访问。分组讨论两种不同的访问方式，取最大值即可。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> max_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        max_ = <span class="built_in">max</span>(max_, dp[n<span class="number">-2</span>]);</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        max_ = <span class="built_in">max</span>(max_, dp[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>备赛百度之星</title>
    <url>/2023/09/18/2023-9-18-%E5%A4%87%E8%B5%9B%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/</url>
    <content><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FLoyd算法"><a href="#FLoyd算法" class="headerlink" title="FLoyd算法"></a>FLoyd算法</h2><p>对于无权的图来说：</p>
<p>若从一顶点到另一顶点存在着一条路径，则称该路径长度为该路径上所经过的边的数目，它等于该路径上的顶点数减1。</p>
<p>由于从一顶点到另一顶点可能存在着多条路径，每条路径上所经过的边数可能不同，即路径长度不同，我们把<strong>路径长度最短（即经过的边数最少）的那条路径叫做最短路径</strong>，其路径长度叫做最短路径长度或最短距离。</p>
<p><img src="/images/2023-9-18-备赛百度之星/20190317133158607.png" alt="img"></p>
<p>对于带权的图来说：</p>
<p>考虑路径上各边上的权值，<strong>则通常把一条路径上所经边的权值之和定义为该路径的路径长度或称带权路径长度</strong>。</p>
<p> 从源点到终点可能不止一条路径，把带权路径长度最短的那条路径称为最短路径，其路径长度（权值之和）称为最短路径长度或者最短距离。</p>
<p><img src="/images/2023-9-18-备赛百度之星/20190317133224707.png" alt="img"></p>
<p><strong>Floyd</strong></p>
<p>任意节点i到j的最短路径两种可能：</p>
<ol>
<li>直接从i到j；</li>
<li>从i经过若干个节点k到j。</li>
</ol>
<p>map（i，j）表示节点i到j最短路径的距离，对于每一个节点k，检查<code>map（i，k）+map（k，j）</code>小于<code>map(i，j)</code>，如果成立，<code>map（i，j） = map（i，k）+map（k，j）</code>；遍历每个k，每次更新的是除第k行和第k列的数。</p>
<p><strong>适用范围：无负权回路即可，边权可正可负，运行一次算法即可求得任意两点间最短路。</strong></p>
<p><strong>无向图构建最短路径长度邻接矩阵核心代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(map[i][j] &gt; map[i][k] + map[k][j])</span><br><span class="line">				map[i][j] = map[i][k] + map[k][j];</span><br></pre></td></tr></table></figure>
<p><strong>有向图构建最短路径长度核心代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(dis[i][j] &gt; dis[i][k] + dis[k][j])</span><br><span class="line">	&#123;</span><br><span class="line">		dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">		path[i][j] = k;	<span class="comment">// 这就是记录路径的数组了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.matiji.net/exam/brushquestion/1/3956/4FCAF025E79704820690062E3FDE6CA1?from=1">洞穴题</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T, n; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">map</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                cin &gt;&gt; map[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数据预处理</span></span><br><span class="line">        <span class="comment">// Floyed 两条路之间没有通路的条件是从j-&gt;k的距离等于j-&gt;i+i-&gt;k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;     <span class="comment">// 中间节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == i || k == i || i == j) <span class="keyword">continue</span>;    <span class="comment">// 第i行或者第i列的都经过i节点，可以直接跳过，对角线上的都是自身到自身</span></span><br><span class="line">                    <span class="keyword">if</span>(map[i][k] &amp;&amp; map[i][j] &amp;&amp; map[j][k])      <span class="comment">// 如果有一个为0，代表了这条路就是行不通的</span></span><br><span class="line">                    <span class="keyword">if</span>(map[j][k] == map[j][i] + map[i][k])&#123;      <span class="comment">// 此处不存在通路</span></span><br><span class="line">                        map[j][k] = map[k][j] = <span class="number">0</span>;</span><br><span class="line">                        cnt ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        cout &lt;&lt; (n * (n - <span class="number">1</span>))/<span class="number">2</span> - cnt &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[i][j])&#123;  <span class="comment">// 当i，j不为0的时候，代表了有通路</span></span><br><span class="line">                    cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小化最大值问题"><a href="#最小化最大值问题" class="headerlink" title="最小化最大值问题"></a>最小化最大值问题</h2><p>看到<strong>最大化最小值</strong>或者<strong>最小化最大值</strong>就要想到<strong>二分答案</strong>，这是一个固定的套路。</p>
<p>二分需要保证单调性的成立，即二分的数越小，越怎么样；二分的数越大，越怎么样？</p>
<p>反之，单调性成立的题目一定能用二分的方法去解决。</p>
<p>如打家劫舍IV，假设小偷偷取的房屋的最大金额为y，显然y在$[nums<em>{min},nums</em>{max}]$中，记f(y)为在最大金额y的限制下，小偷可以偷到的啊房屋，那么f(y)&gt;=k的最小y就是小偷的最小窃取能力</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCapability</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> right = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> visted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&lt;=mid &amp;&amp; !visted)&#123;</span><br><span class="line">                    visted = <span class="literal">true</span>;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    visted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= k)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><p><strong>一维前缀和</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(nums.size(), nums[<span class="number">0</span>])</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++ i)&#123;</span><br><span class="line">    prefix[i] = prefix[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一维差分</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> l, m, x, y;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        a[x] ++; </span><br><span class="line">        a[y + <span class="number">1</span>] --;</span><br><span class="line">    &#125;<span class="comment">// x++ y+1--的操作能够使得[x, y]区间内的所有元素加1;</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i ++)&#123;</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!a[i]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + !a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二维前缀和</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, R, x, y, v;</span><br><span class="line"><span class="type">int</span> g[<span class="number">5010</span>][<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; R;</span><br><span class="line">    <span class="type">int</span> xx = R, yy = R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">        xx = <span class="built_in">max</span>(x + <span class="number">1</span>, xx);</span><br><span class="line">        yy = <span class="built_in">max</span>(y + <span class="number">1</span>, yy);</span><br><span class="line">        g[x + <span class="number">1</span>][y + <span class="number">1</span>] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建二位前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= xx; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= yy; ++j)&#123;</span><br><span class="line">            g[i][j] = g[i<span class="number">-1</span>][j] + g[i][j<span class="number">-1</span>] + g[i][j] - g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据预处理</span></span><br><span class="line">    <span class="comment">// 代码逻辑正文</span></span><br><span class="line">    <span class="type">int</span> sum_ = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对前缀和数组求(x1,y1)-&gt;(x2,y2)矩阵间的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = R; i &lt;= xx; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = R; j &lt;= yy; ++j)&#123;</span><br><span class="line">            sum_ = <span class="built_in">max</span>(sum_, g[i][j] - g[i-R][j] - g[i][j-R] + g[i-R][j-R]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯搜索"><a href="#回溯搜索" class="headerlink" title="回溯搜索"></a>回溯搜索</h2><p>回溯是一个纯暴力的搜索方法，可以抽象为一个树形结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">		收集结果;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(集合元素)&#123;</span><br><span class="line">		处理节点</span><br><span class="line">		递归函数</span><br><span class="line">		回溯操作</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此回溯是一个先到最底层，再一步一步撤销操作的过程。</p>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fast_pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;  </span><br><span class="line">        <span class="keyword">if</span> (p % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            result = result * x % MOD;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(<span class="number">56</span>, <span class="number">48</span>) &lt;&lt; endl;  <span class="comment">// 输出应该是 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>三个元素如何连通</p>
<p>只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并查集初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断两个元素是否在同一个集合里</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路径压缩</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>整体模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><p>“区间DP”是一种动态规划的变种，它用于处理一系列元素和它们之间的相互关系。在这种情境中，我们通常对一个区间或一段连续的子序列进行操作，尝试找到一种最优的方法来处理或组合这些元素。为了找到整个区间的最优解，我们经常需要先解决该区间的子区间问题。</p>
<p>区间DP的常见特征是：</p>
<ol>
<li>定义状态通常涉及一个或多个区间，如 <code>dp[i][j]</code> 表示从第 <code>i</code> 个到第 <code>j</code> 个元素的某种最优解。</li>
<li>转移方程可能基于更小的子区间，例如，要计算 <code>dp[i][j]</code>，可能需要先知道 <code>dp[i][k]</code> 和 <code>dp[k+1][j]</code> 的值。</li>
<li>通常有一个外层循环，用于确定子区间的长度，从而确保在计算一个区间的答案之前，其所有子区间的答案都已被计算出来。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= j - <span class="number">1</span>; ++k)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], d[i]*d[j]*d[k] + dp[i][k] + dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/09/20/2023-9-20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="C-S系统和P2P系统"><a href="#C-S系统和P2P系统" class="headerlink" title="C/S系统和P2P系统"></a>C/S系统和P2P系统</h2><p>C/S系统的可扩展性较差，加内存/硬盘…</p>
<p>而P2P系统的可扩展性较好，管理起来较为困难，每个节点有上限和下限。</p>
<p><strong>混合的模式</strong></p>
<p>QQ（当然现在不是）如查询的时候用C/S方式，对话的时候用P2P方式。</p>
<p>不同主机通过交换<strong>报文</strong>来进行通信。</p>
<p>客户端进程：发起通信的进程</p>
<p>服务器进程：等待连接的进程</p>
<p>注意：P2P架构的应用也有客户端进程和服务器进程之分（每个peer既是服务器又是客户端）。</p>
<h2 id="分布式进程通信需要解决的问题"><a href="#分布式进程通信需要解决的问题" class="headerlink" title="分布式进程通信需要解决的问题"></a><strong>分布式进程通信需要解决的问题</strong></h2><ol>
<li>标识和寻址<strong>（服务用户）</strong></li>
<li>传输层-应用层所提供的服务形式什么，如何调用<strong>（服务）</strong><ul>
<li>位置：层间界面的SAP（TCP/IP: socket）</li>
<li>形式：应用程序接口API（TCP/IP: socket API）</li>
</ul>
</li>
<li>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用<strong>（用户使用服务）</strong><ul>
<li>定义应用层协议：报文格式，解释，时序等。</li>
<li>编制程序，使用OS提供的API，调用网络基础设施提供通信服务传报文，实现应用时序等。</li>
</ul>
</li>
</ol>
<h3 id="寻址："><a href="#寻址：" class="headerlink" title="寻址："></a><strong>寻址：</strong></h3><ol>
<li>主机在哪？</li>
<li>UDP还是 TCP？</li>
<li>UDP/TCP上有很多端口，在哪个上面跑？</li>
</ol>
<h2 id="层间接口需要提供的信息："><a href="#层间接口需要提供的信息：" class="headerlink" title="层间接口需要提供的信息："></a><strong>层间接口需要提供的信息：</strong></h2><ol>
<li>发什么：SDU（传的货物，主要内容）</li>
<li>谁传的：IP+PORT（端口号，UDP/TCP的端口号）</li>
<li>传给谁：对面的IP+TCP（UDP）</li>
</ol>
<p>收发是相互的。</p>
<p>如果Socket API每次传输报文都携带这么多信息，太繁琐，不易于管理。</p>
<p>用代号来标示通信的双方或者单方：<strong>socket</strong>（文件描述符，TCP：四元组，UDP：两元组）</p>
<blockquote>
<p>为什么TCP是四元组而UDP是两元组？</p>
<p>因为TCP是需要返回的，而UDP只需要发出即可。</p>
</blockquote>
<p>就像OS打开文件返回的句柄一样。</p>
<ul>
<li>对句柄的操作，就是对文件的操作</li>
</ul>
<h2 id="TCP-socket："><a href="#TCP-socket：" class="headerlink" title="TCP socket："></a><strong>TCP socket：</strong></h2><ul>
<li>TCP服务，两个进程之间的通信需要之前<strong>要建立连接</strong>。<ul>
<li>两个进程通信会持续一段时间，通信关系稳定。</li>
</ul>
</li>
<li>可以用一个整数表示两个应用实体之间的<strong>通信关系</strong>（因此发的时候可以只用传两个东西，一个socket+数据本身），<strong>本地</strong>标识。</li>
<li>穿过层间接口的信息量很小</li>
<li>TCP socket：源IP，源端口，目标IP，目标端口。</li>
</ul>
<p>其实就是把信息给压缩了，就是在传输地址时本地之间的一个简单的标识符，仅仅只在本地适用，在本地的层间传递的时候能够大大减少传递时候发出的层间信息量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>SOCKET</th>
<th>源IP</th>
<th>源PORT</th>
<th>目标IP</th>
<th>目标PORT</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="UDP-socket："><a href="#UDP-socket：" class="headerlink" title="UDP socket："></a><strong>UDP socket：</strong></h2><ul>
<li>UDP服务，两个进程之间的通信需要之前无需建立连接。<ul>
<li>每个报文都是独立传输的</li>
<li>前后报文可能给不同的分布式进程</li>
</ul>
</li>
<li>因此，只能用一个整数表示本应用实体的标识，不代表一个对话关系。（因此传输的时候还是需要发三个东西，一个socket+数据本身+对方的IP和port）<ul>
<li>因为这个报文可能传给另外一个分布式进程</li>
</ul>
</li>
<li>穿过层间接口的信息大小最小</li>
<li>UDP socket：本IP，本端口</li>
<li>但是传输报文时，必须要提供对方IP，port<ul>
<li>接受报文时，传输层需要上传对方的IP，port</li>
</ul>
</li>
</ul>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><ul>
<li>定义了：运行在不同端系统上的应用进程如何相互交换报文。<ul>
<li>报文类型</li>
<li>语法</li>
<li>语义</li>
<li>规则</li>
</ul>
</li>
<li>应用协议仅仅是应用的一个组成部分。<ul>
<li>Web应用：HTTP协议，web客户端，web服务器，HTML</li>
</ul>
</li>
</ul>
<p><strong>公开协议：</strong></p>
<ul>
<li>由RFC文档定义</li>
<li>允许互操作</li>
<li>如HTTP，SMTP</li>
</ul>
<p><strong>专用（私有）协议：</strong></p>
<ul>
<li>协议不公开</li>
<li>如：Skype</li>
</ul>
<p><strong>衡量指标</strong></p>
<ol>
<li>可靠性</li>
<li>延迟</li>
<li>吞吐：单位时间的发出和<strong>有效的</strong>泵出。</li>
<li>安全性<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性（鉴别）</li>
</ul>
</li>
</ol>
<p>SSL（在应用层）可以为APP提供安全性的服务。</p>
<p>HTTP+S ==&gt; HTTPS，web应用跑在TCPoverSSL之上。</p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>​        FTP是一个经典的应用，文件传输协议。</p>
<ul>
<li>向远程主机上传输文件或者从远程主机接收文件</li>
<li>客户/服务器模式<ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>FTP: RFC 959</li>
<li>FTP: 服务器端口21</li>
</ul>
<p>客户端向服务器发送数据叫做上载，服务器向客户端发送数据叫下载，上载和下载默认是在客户端的角度去说的。</p>
<h2 id="电子邮件email"><a href="#电子邮件email" class="headerlink" title="电子邮件email:"></a>电子邮件email:</h2><p><strong>3个主要组成部分：</strong></p>
<ul>
<li>用户代理</li>
<li>邮件服务器<ul>
<li>邮箱中管理和维护邮件</li>
<li>输出<strong>报文队列</strong>保持待发 送邮件报文</li>
<li>邮件服务器之间的SMTP协议：发送email报文<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
</li>
</ul>
</li>
<li>简单邮件传输协议：SMTP</li>
</ul>
<p>SMTP:</p>
<ol>
<li><p>使用TCP在客户端和服务器之间传送报文，端口号为25</p>
</li>
<li><p>直接传输：从发送方服务器到接收方服务器</p>
</li>
<li><p>传输的三个阶段</p>
<ul>
<li><p>握手</p>
</li>
<li><p>传输报文</p>
</li>
<li><p>关闭</p>
</li>
</ul>
</li>
<li><p>命令/相应交互：</p>
<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul>
</li>
<li><p>报文必须为7位的ASCII码，邮件内容必须在规定的ASCII码范围内。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首部行：如，</span><br><span class="line">- to</span><br><span class="line">- From</span><br><span class="line">- Subject</span><br><span class="line">与SMTP命令不同</span><br><span class="line">主体：</span><br><span class="line">只能是ASCII码</span><br></pre></td></tr></table></figure>
<p>报文格式：多媒体扩展</p>
<p>MIME: 多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056。</p>
<p>在报文的首部用额外的行申明MIME内容类型。</p>
<p>Base64编码：将若干个不在ASCII码字符之间的字节转化为较长的在ASCII码值范围的字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALICE-&gt;用户代理-smtp-&gt;发送方邮件服务器-smtp-&gt;接收方邮件服务器-pop3、tmap、http-&gt;用户代理-&gt;BOB</span><br><span class="line">前两跳都是推，后面是拉</span><br></pre></td></tr></table></figure>
<p>SMTP：传送到接收方的邮件服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POP3协议</span><br><span class="line">客户端命令：</span><br><span class="line">	-user：申明用户名</span><br><span class="line">	-pass：口令</span><br><span class="line">事务处理阶段，客户端：</span><br><span class="line">	-list：报文号列表</span><br><span class="line">	-retr：根据报文号检索报文</span><br><span class="line">	-dele：删除</span><br><span class="line">	-quit</span><br><span class="line">先前的例子使用“下载并删除”模式</span><br><span class="line">	- 如果改变客户机，Bob不能阅读邮件，比如在平板上查看了邮件系统，再用电脑去访问邮箱就找不到那封邮件了。</span><br><span class="line">“下载并保留”：不同客户机上为报文的拷贝</span><br><span class="line">POP3在会话中是无状态的</span><br><span class="line"></span><br><span class="line">IMAP</span><br><span class="line">IMAP服务器将每个报文与一个文件夹联系起来</span><br><span class="line">允许用户用目录来阻止报文</span><br><span class="line">允许用户读取报文组件</span><br><span class="line">IMAP在会话过程中保留用户状态</span><br><span class="line">	目录名、报文ID与目录之间映射</span><br></pre></td></tr></table></figure>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><strong>DNS的必要性：</strong></p>
<ul>
<li>IP地址标识主机，路由器</li>
<li>但IP地址不好记忆，不便人类使用</li>
<li>人类一般倾向于使用一些有意义的字符串来表示Internet上的设备</li>
<li>存在着“字符串”——IP地址的转换的必要性</li>
<li>人类用户提供要访问机器的“字符串”名称</li>
<li>由DNS负责转换成为二进制的网络地址</li>
</ul>
<p><strong>DNS系统需要解决的问题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题1：如何命名设备</span><br><span class="line"></span><br><span class="line">问题2：如何完成名字到IP地址的转换</span><br><span class="line"></span><br><span class="line">问题3：如何维护</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APPANET</span><br></pre></td></tr></table></figure>
<p><strong>DNS的主要思路：</strong></p>
<ol>
<li>分层的、基于域的命名机制</li>
<li>若干分布式的数据库完成名字到IP地址的转换</li>
<li>运行在UDP之上端口号为53的应用服务</li>
<li>核心的Internet功能，但以应用层协议实现<ul>
<li>在网络边缘处理复杂性</li>
</ul>
</li>
</ol>
<p><strong>DNS的主要目的：</strong></p>
<ol>
<li>实现主机-IP地址的转换</li>
<li>其他目的<ul>
<li><strong>主机别名</strong>到<strong>规范名字</strong>的转换：Host aliasing</li>
<li>邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing</li>
<li><strong>负载均衡</strong>：Load Distribution</li>
</ul>
</li>
</ol>
<p><strong>DNS根名字服务器</strong></p>
<p><strong>DNS名字空间</strong></p>
<ul>
<li><p>域名（Domain Name）</p>
<ul>
<li>从本域往上，直到树根</li>
<li>中间使用”.”区别不同的域名</li>
</ul>
</li>
<li><p>域名的管理</p>
<ul>
<li><p>一个域管理旗下的子域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.jp被划分为ac.jp co.jp</span><br><span class="line">.cn被划分为 edu.cn com.cn</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的域，必须征得它所属域的同意</p>
</li>
</ul>
</li>
<li><p>域与物理网络无关</p>
<ul>
<li>域遵从组织界限，而不是物理网络</li>
</ul>
</li>
<li><p>一个名字服务器的问题</p>
<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离的集中式数据库</li>
</ul>
</li>
<li><p>区域</p>
<ul>
<li>区域的划分有区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li>
<li>名字服务器：<ul>
<li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2603. 收集树中金币</title>
    <url>/2023/09/21/2023-9-21-2603.-%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%AD%E9%87%91%E5%B8%81/</url>
    <content><![CDATA[<h2 id="2603-收集树中金币"><a href="#2603-收集树中金币" class="headerlink" title="2603. 收集树中金币"></a><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/">2603. 收集树中金币</a></h2><p><img src="/images/2023-9-21-2603.-收集树中金币/image-20230921094017336.png" alt="image-20230921094017336"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="关键点1"><a href="#关键点1" class="headerlink" title="关键点1"></a>关键点1</h4><p>​        对于价值为0的叶子节点a，在它的位置上所能搜到的金币一定能在它的父节点a’上搜索到。</p>
<h4 id="关键点2"><a href="#关键点2" class="headerlink" title="关键点2"></a>关键点2</h4><p>​        对于有价值的叶子节点，在搜索过程中我们只需要走到它的父节点的父节点的时候，就能够搜到这个节点。</p>
<h3 id="关键点3"><a href="#关键点3" class="headerlink" title="关键点3"></a>关键点3</h3><p>​        最后我们需要返回的是一定需要走过的边数×2</p>
<p>结合以上的关键点，我们可以对原图进行两次<strong>拓扑排序</strong>。</p>
<p>第一次删除所有的价值为0的叶子节点，这在我们的图中是不必要的存在（注意，如果删除了叶子节点之后又产生了新的叶子节点，同样删除该节点，这样的操作可以通过一个循环的队列来实现）。这样，经过第一次拓扑排序以后，剩余的叶子节点均为有价值的。</p>
<p>第二次，删除所有的叶子节点，删除之后如果产生了新的叶子节点，将这个节点一并删去（因为这样的节点是不会对其它金币的获取产生影响的，与此同时如果直接删去对原金币的获取也不造成影响）。</p>
<p>最后返回剩余的边的数目。</p>
<p>在代码的实现中，有几个点需要注意。</p>
<ol>
<li>代码的初始化<br>我们在代码的开始时候就应该定义好剩余的边，一个节点的连通数（当连通数为1的时候它就是叶子节点），一个节点连通的其它节点（用一个<code>vector&lt;int&gt;</code>去表示其它的节点，整体的数据结构为<code>vector&lt;vector&lt;int&gt; &gt;</code>，下标代表了该节点）。</li>
<li>删除一个叶子节点我们需要进行哪些操作？<br>首先对于其本身，它的连通数变为0。<br>再对于与之相连的节点，它们每一个点的连通数都减少1（如果需要遍历它们的连通节点，对于原叶子节点，可以通过叶子节点的连通数为0来剔除）。<br>再对于边的数目，减一即可。</li>
</ol>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">collectTheCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>() + <span class="number">1</span>; <span class="comment">// 一共有n个结点</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">node</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">out</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; edge:edges)&#123;</span><br><span class="line">            <span class="type">int</span> x = edge[<span class="number">0</span>],  y = edge[<span class="number">1</span>];</span><br><span class="line">            node[x] ++;</span><br><span class="line">            node[y] ++;</span><br><span class="line">            out[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            out[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left_edges = n - <span class="number">1</span>; <span class="comment">// 剩余的边数</span></span><br><span class="line">        <span class="comment">// 删除叶子节点</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; qe;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(node[i] == <span class="number">1</span> &amp;&amp; coins[i] == <span class="number">0</span>) qe.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(qe.<span class="built_in">size</span>())&#123;</span><br><span class="line">            left_edges--;</span><br><span class="line">            <span class="type">int</span> front = qe.<span class="built_in">back</span>();</span><br><span class="line">            node[front]--;</span><br><span class="line">            qe.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; element:out[front])&#123;</span><br><span class="line">                node[element] --;</span><br><span class="line">                <span class="keyword">if</span>(node[element] == <span class="number">1</span> &amp;&amp; coins[element] == <span class="number">0</span>) qe.<span class="built_in">push_back</span>(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到爆金币的叶子的父亲的父亲，每找到一个爆了金币的，边的数目就减去2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node[i] == <span class="number">1</span> &amp;&amp; coins[i]) qe.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        left_edges -= qe.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x: qe)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y: out[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--node[y] == <span class="number">1</span>)&#123;</span><br><span class="line">                    left_edges -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left_edges &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * left_edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用github</title>
    <url>/2023/09/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github/</url>
    <content><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="创建一个github账户"><a href="#创建一个github账户" class="headerlink" title="创建一个github账户"></a>创建一个github账户</h2><p>​        在github上创建一个账户，然后创建属于自己的仓库。</p>
<h2 id="安装git工具"><a href="#安装git工具" class="headerlink" title="安装git工具"></a>安装git工具</h2><p>​        为了对仓库进行操作，我们需要安装一个用于操作仓库的工具，即git，在安装过程中一直下一步即可。</p>
<h1 id="仓库代码上传"><a href="#仓库代码上传" class="headerlink" title="仓库代码上传"></a>仓库代码上传</h1><p>​        对一个仓库进行操作，你需要拿到你的git仓库（拉），然后对仓库进行修改，改完之后要把你做的修改上传到仓库（推）。</p>
<p>​        首先在你需要的文件夹(假设你已经安装好了git)，右键点击<code>Git Bash Here</code>.</p>
<p><img src="/images/如何使用github/image-20231007234246752.png" alt="image-20231007234246752"></p>
<p>git工具基本界面</p>
<p><img src="/images/如何使用github/image-20231007235140876.png" alt="image-20231007235140876"></p>
<h2 id="拉"><a href="#拉" class="headerlink" title="拉"></a>拉</h2><p>在创建仓库后，你可以在github上找到你的仓库，可以看到这一行信息。</p>
<p><img src="/images/如何使用github/image-20231007234932981.png" alt="image-20231007234932981"></p>
<p>这里的地址就可以用来操作你的仓库了。</p>
<p>输入<code>git clone addr(addr为你的地址)</code>，就可以把你的仓库从github拉到本地了。</p>
<p>随后将你需要上传的文件copy一份到文件夹中，就完成了修改的操作。</p>
<h2 id="推"><a href="#推" class="headerlink" title="推"></a>推</h2><p>完成了对git的修改之后，就可以上传你的仓库了。</p>
<p><code>cd</code>到你的本地仓库中。</p>
<p>再次之前你需要创建一个token。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username:repo </span><br><span class="line">Password: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</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin  https://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@github.com/Zzr-rr/&lt;&gt;.git/</span><br></pre></td></tr></table></figure>
<p>比如这是我的token（我写这篇文章就是为了记一下我这个token），如何创建这里有详细的<a href="https://blog.csdn.net/yjw123456/article/details/119696726">教程</a>。</p>
<p><strong>链接操作：</strong></p>
<p><img src="/images/如何使用github/image-20231008000940088.png" alt="image-20231008000940088"></p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/user_name/project_01.git</span><br><span class="line">git branch -M main </span><br><span class="line">git push -u origin main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/user_name/project_01.git</span><br><span class="line">git branch -M main </span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>强烈建议看一下这篇<a href="https://blog.csdn.net/m0_61874034/article/details/125098545?ops_request_misc=%7B%22request%5Fid%22%3A%22169669461816800215031313%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169669461816800215031313&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125098545-null-null.142^v95^insert_down28v1&amp;utm_term=github操作&amp;spm=1018.2226.3001.4187">GitHub入门操作（详细）</a>，有利于加深对Git分支和协同办公的理解。</p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署跌倒算法文档</title>
    <url>/2023/11/03/2023-11-3-Docker%E9%83%A8%E7%BD%B2%E8%B7%8C%E5%80%92%E7%AE%97%E6%B3%95%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h1><p>​        目前有一个跌倒算法，demo已经在主机（Windows）上跑通，需要将其部署到linux主机上并且通过docker发布。</p>
<p>​        本文记录部署发布的全过程。开发主机为CentOs-7-x86_64。</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>​        Docker是一个包管理容器，开发过程中常出现代码在我的主机能跑而在别的平台上不能跑的问题，此时就需要Docker来发挥作用，Docker就是在一定程度上发挥了虚拟机的作用，同时也避免了虚拟机的高占用等等相关问题。</p>
<h2 id="1-安装docker-ce社区版"><a href="#1-安装docker-ce社区版" class="headerlink" title="1. 安装docker-ce社区版"></a>1. 安装docker-ce社区版</h2><ul>
<li><p>配置repo源<br>repo源是软件仓库源，是存储软件包和相关信息的位置（可以类比python中使用pip安装时使用的镜像源）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line">yum clean all: 清除yum缓存，删除已下载的软件包和元数据</span><br><span class="line">yum makecache: 重新生成yum缓存，它会从配置的镜像源中下载软件包的元数据（如软件包列表、版本信息等），并将其存储在本地以供后续的软件包管理操作使用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <strong>执行结果</strong><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103211448247.png" alt="image-20231103211448247"></p>
<p>  <img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103211507270.png" alt="image-20231103211507270"></p>
<p>  <img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103211559436.png" alt="image-20231103211559436"><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103211633349.png" alt="image-20231103211633349"></p>
<ul>
<li><p>查看可下载版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103211936973.png" alt="image-20231103211936973"></p>
</li>
<li><p>安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最新版</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本</span></span><br><span class="line">yum install -y docker-ce-<span class="number">23.0</span><span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103212727542.png" alt="image-20231103212727542"></p>
</li>
</ul>
<h2 id="2-启动docker-ce社区版"><a href="#2-启动docker-ce社区版" class="headerlink" title="2.启动docker-ce社区版"></a>2.启动docker-ce社区版</h2><ul>
<li><p>设置开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103212905398.png" alt="image-20231103212905398"></p>
</li>
<li><p>启动docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 查看docker信息</span><br><span class="line">docker version</span><br><span class="line">## 查看docker信息</span><br><span class="line">docker info</span><br><span class="line">## 查看镜像</span><br><span class="line">docker images</span><br><span class="line">## 搜索镜像</span><br><span class="line">docker search ubuntu</span><br><span class="line">## 下载镜像</span><br><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-配置镜像加速"><a href="#3-配置镜像加速" class="headerlink" title="3. 配置镜像加速"></a>3. 配置镜像加速</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span><br></pre></td></tr></table></figure>
<p>首先进入以上网址，按照指示来安装加速器（每个账号不同）。</p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231103213915133.png" alt="image-20231103213915133"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://pf4hecjj.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重新加载配置并且重启</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h1 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h1><ul>
<li>需求：基于docker创建在ubuntu20.04系统上运行跌倒算法</li>
<li>流程：<ul>
<li>在centos7.9 + 安装docker</li>
<li>基于docker软件<ul>
<li>获取基础镜像ubuntu20.04</li>
<li>在基础镜像基础上构建自定义镜像【ubuntu20.04 + python + 代码】</li>
<li>基于镜像创建容器 + 运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search ubuntu</span><br><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<p>这种方式相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:latest</span><br></pre></td></tr></table></figure>
<p>指定版本的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:20.04</span><br></pre></td></tr></table></figure>
<h2 id="2-构建镜像"><a href="#2-构建镜像" class="headerlink" title="2. 构建镜像"></a>2. 构建镜像</h2><h3 id="2-1-Dockerfile-语法"><a href="#2-1-Dockerfile-语法" class="headerlink" title="2.1 Dockerfile + 语法"></a>2.1 Dockerfile + 语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Dockerfile</span><br><span class="line"># Base images 基础镜像</span><br><span class="line">FROM ubuntu:20.04</span><br><span class="line"></span><br><span class="line"># MAINTAINER 维护者信息</span><br><span class="line">maintainer zhuzr 10221111@cumt.edu.cn</span><br><span class="line"></span><br><span class="line"># RUN 执行以下命令</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install python3 python3-pip -y</span><br><span class="line">RUN pip3 install -r fall-demo/requirements.txt</span><br><span class="line">RUN mdkir -p /fall</span><br><span class="line"></span><br><span class="line"># 拷贝文件至工作目录</span><br><span class="line">COPY fall-demo /fall/fall-demo</span><br><span class="line"></span><br><span class="line"># 工作目录</span><br><span class="line">WORKDIR /fall</span><br><span class="line"></span><br><span class="line"># EXPOSE 映射端口</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 容器启动时执行命令</span><br><span class="line">CMD [&quot;python3&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在docker宿主机centos7.9创建2个文件：</p>
<ul>
<li>Dockerfile</li>
<li>fall-demo</li>
</ul>
</li>
<li><p>命令构建自定义镜像（模板）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t fall/demo:0.0 . -f Dockerfile</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-2-基于镜像创建容器-运行"><a href="#2-2-基于镜像创建容器-运行" class="headerlink" title="2.2 基于镜像创建容器 + 运行"></a>2.2 基于镜像创建容器 + 运行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run fall/demo:0.0</span><br><span class="line">docker run -p 80:8000 fall/demo:0.0 # 将docker端口80映射到宿主机的8000端口（端口转发）</span><br><span class="line">docker run -d -p 80:8000 fall/demo:0.0 # 到后台运行,避免卡住终端的问题</span><br><span class="line">docker run -d -p 83:8000 --name v222 fall/demo:0.0 # 自己为其命名</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看目前正在运行的所有容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a 	# 查看所有运行过的容器</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 550</span><br><span class="line">docker stop b93 f33 dfa</span><br><span class="line"># 输入的是CONTAINER ID 的前几位</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Docker实操"><a href="#Docker实操" class="headerlink" title="Docker实操"></a>Docker实操</h1><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>​        详细说说dockerfile的几个写法，在Docker编写的指令大致上可以分为两类：1.创建镜像运行    2.容器运行</p>
<ul>
<li><p>Docker指定基础镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	FROM &lt;image&gt;</span><br><span class="line">	FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">示例：</span><br><span class="line">	FROM mysql:5.7</span><br><span class="line">注意：</span><br><span class="line">	tag是可选的，如果不使用tag时，会使用latest版本的基础镜像</span><br></pre></td></tr></table></figure>
</li>
<li><p>MAINTAINER 镜像维护者的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	MAINTAINER &lt;name&gt;</span><br><span class="line">示例：</span><br><span class="line">	MAINTAINER zhuzr</span><br><span class="line">	MAINTAINER 10221111@cumt.edu.cn</span><br><span class="line">	MAINTAINER zhuzr 10221111@cumt.edu.cn</span><br></pre></td></tr></table></figure>
</li>
<li><p>ENV</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">	ENV &lt;key&gt;=&lt;value&gt;</span><br><span class="line">示例：</span><br><span class="line">	ENV myName John</span><br><span class="line">	ENV myCat= fluffy</span><br></pre></td></tr></table></figure>
</li>
<li><p>COPY|ADD 添加本地文件到镜像中，ADD会多一个自动解压的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY &lt;str&gt;... &lt;dest&gt;</span><br><span class="line">示例：</span><br><span class="line">	ADD hom* /mydir/ 	# 添加所有以&quot;hom&quot;开头的文件</span><br><span class="line">	ADD test relativeDir/	# 添加&quot;test&quot;到 $WORKDIR/relativeDir/</span><br><span class="line">	ADD test /absoluteDir/ 	# 添加&quot;test&quot;到 /absoluteDir/ </span><br></pre></td></tr></table></figure>
</li>
<li><p>WORKDIR  工作目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	WORKDIR /path/to/workdir</span><br><span class="line">示例：</span><br><span class="line">	WORKDIR /a # 此时的工作目录为/a</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​          </p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t fall/demo:1.0 . -f Dockerfile</span><br><span class="line">docker build -t fall/demo:1.1 . -f Dockerfile</span><br></pre></td></tr></table></figure>
<pre><code>   这样子构建会进行缓存，即会使用原来的代码进行构建，下次构建的时候会采用原来的缓存进行构建（而不是使用新的文件，当然，这种方式在一定程度上也加快了构建速度）。
</code></pre><p>​        如果不想用缓存，可以在构建前使用 —no-cache 指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t fall/demo:1.0 . -f Dockerfile  --no-cache</span><br></pre></td></tr></table></figure>
<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><ol>
<li><p>容器中必须要有一个前台进程，否则创建之后会立即销毁。</p>
</li>
<li><p>宿主机centos7.9运行是否需要前台？后台：使用-d指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:8000 fall/demo</span><br></pre></td></tr></table></figure>
<p>仅：容器内部前台进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 81:8000 demo/fall:1.0</span><br></pre></td></tr></table></figure>
<p>仅：宿主机后台进行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:8000 ubuntu:20.04</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="容器常见指令"><a href="#容器常见指令" class="headerlink" title="容器常见指令"></a>容器常见指令</h2><h3 id="创建容器-1"><a href="#创建容器-1" class="headerlink" title="创建容器"></a>创建容器</h3><ol>
<li><p>镜像含前台进程，创建容器+启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:8000 demo/test</span><br></pre></td></tr></table></figure>
</li>
<li><p>镜像不含前台进程，创建容器+启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:8000 ubuntu:20.04</span><br></pre></td></tr></table></figure>
<ol>
<li><p>1 进入系统 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -ti -p 80:8000 ubuntu:20.04 bash</span><br><span class="line">docker run -ti -p 80:8000 ubuntu:20.04 sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231104223415267.png" alt="image-20231104223415267"></p>
</li>
<li><p>2 添加前台进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -ti ubuntu:20.04 ping baidu.com</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl + P + Q</span><br></pre></td></tr></table></figure>
<h3 id="销毁进程"><a href="#销毁进程" class="headerlink" title="销毁进程"></a>销毁进程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a # 查看一下所有容器</span><br><span class="line">docker ps # 查看一下正在运行的容器</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器ID</span><br><span class="line">docker rm 容器ID</span><br></pre></td></tr></table></figure>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ol>
<li><p>镜像含前台进程，创建容器+启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:8000 demo/test:1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>镜像不含前台进程，进入容器后操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -ti ubuntu:20.04 bash</span><br><span class="line">docker run -ti ubuntu:20.04 sh</span><br><span class="line"></span><br><span class="line"># 如果想要退出的时候删去容器</span><br><span class="line">docker run -ti --rm ubuntu:20.04 bash</span><br><span class="line">docker run -ti --rm ubuntu:20.04 sh</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="导入导出和发布"><a href="#导入导出和发布" class="headerlink" title="导入导出和发布"></a>导入导出和发布</h1><ol>
<li><p>Dockerfile —&gt; 构建 —&gt; 本地镜像库</p>
</li>
<li><p>本地导入导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image save &lt;name&gt;&gt;&lt;dest&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231104234325351.png" alt="image-20231104234325351"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image load -i &lt;dest&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231104234424697.png" alt="image-20231104234424697"></p>
</li>
<li><p>发布（注册DockerHub）</p>
</li>
</ol>
<h1 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h1><p>​        梳理了一下前置的知识之后，我们正式开始部署我们的跌倒算法，首先了解一下需要部署文件的大致框架。</p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105091442457.png" alt="image-20231105091442457"></p>
<p>​        文件中有一个<code>test_demo.py</code>，首要目的就是能够在容器中跑通这个代码。</p>
<p>​        运行<code>test_demo</code>后，应当能够在<code>results</code>文件夹下看到36张处理后的图片。</p>
<p><strong>执行界面</strong><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105091730777.png" alt="image-20231105091730777"></p>
<p><strong>执行结果</strong></p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105091824684.png" alt="image-20231105091824684"></p>
<p><strong>为了方便起见，这里选择直接使用docker desktop进行开发</strong></p>
<p>简单说一下<code>docker desktop</code>是什么。</p>
<p>一般来说我们开发项目的流程是Windows开发-&gt;cp至Linux-&gt;使用docker打包。</p>
<p>中途需要经过linux的中转，对于我们平时的开发来说并不方面，因此<code>docker for windows</code>的概念应运而生。即在windows中使用docker，因此可以省去一些额外的步骤，在windows中安装docker可以上网自行查询方法（需要WSL）。我们选择的是<code>docker desktop</code>。</p>
<p>类似于在linux的终端，安装好docker后，在windows的终端中也可以使用docker的相关指令。</p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105114839387.png" alt="image-20231105114839387"></p>
<p>打开我们安装好的<code>docker desktop</code>，简单介绍一下界面。</p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231106213326163.png" alt="image-20231106213326163"></p>
<p>如图所示，整体的界面对于linux来说更加直观，我们点进右上角进行镜像的配置。</p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231106213437573.png" alt="image-20231106213437573"></p>
<p>稍微了解一下，就可以开始使用了，在cmd中使用<code>docker run</code>创建容器后，能够在主界面的左侧<code>Containers</code>中看到我们创建好的容器。</p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231106213622532.png" alt="image-20231106213622532"></p>
<p>使用docker创建容器后，进入容器内（可以直接在docker desktop中使用终端(exec)）直接运行demo文件，查看报错信息，一一调试。</p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105114424614.png" alt="image-20231105114424614"></p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105114940323.png" alt="image-20231105114940323"></p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105114948551.png" alt="image-20231105114948551"></p>
<p><img src="/images/2023-11-3-Docker部署跌倒算法文档/image-20231105115243852.png" alt="image-20231105115243852"></p>
<p><strong>打包</strong></p>
<p>容器调整完成之后，直接对镜像进行打包即可。</p>
<p>打包分为两步：</p>
<ol>
<li><p>首先将容器打包为镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit &lt;mycontainer&gt; &lt;new_image_name&gt;:&lt;new_tag&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再将镜像导出为tar文件供其他人使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o &lt;images&gt;.tar &lt;images&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果想要加载别人的包，可以使用这个命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load [options] &lt; file.tar</span><br></pre></td></tr></table></figure>
<p> 至此，打包工作结束。</p>
]]></content>
      <categories>
        <category>部署</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2023/11/13/2023-11-13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h2><p>我们写的程序和APP的大小可能较大，如果要将这么大的数据全部放入内存并且连续存放的话，这就意味着我们必须在主存中找到一块连续的位置用来存放我们的数据。</p>
<p>因此我们会引入一个新的概念<strong>页面</strong>。</p>
<p>并且我们可以给每一个页面进行编号，每一个页面的大小都是原来的$1/n$。</p>
<p><img src="/images/2023-11-13-计算机组成原理/image-20231113114335282.png" alt="image-20231113114335282"></p>
<p>页面存储系统：一个程序（进程）在逻辑上被分为若干个大小相等的<strong>“页面”</strong>，<strong>“页面”大小与“块”的大小相同</strong>。每个页面可以离散地放入不同的主存块中。</p>
<h3 id="虚地址-vs-实地址"><a href="#虚地址-vs-实地址" class="headerlink" title="虚地址 vs 实地址"></a>虚地址 vs 实地址</h3><p><strong>逻辑地址（虚地址）</strong>：程序员视角看到的地址。</p>
<p><strong>物理地址（实地址）</strong>：实际在主存中的地址。</p>
<p>操作系统将逻辑地址映射为与之对应的物理地址</p>
<p>逻辑页号映射为与之对应的主存块号。</p>
<p><img src="/images/2023-11-13-计算机组成原理/image-20231113115018210.png" alt="image-20231113115018210"></p>
<p>操作系统的映射操作（将逻辑地址转为物理地址）一般通过<strong>页表</strong>（记录了每个逻辑页面存放在哪个主存块中）进行操作。</p>
<blockquote>
<p>页表基址寄存器：存放了页表基地址，指明了页表在主存中的存放地址；将近期访问的页表项放入更高速的存储器，可加快地址变换的速度。因此我们可以引入一个新的概念—&gt;快表(TLB)</p>
</blockquote>
<p><img src="/images/2023-11-13-计算机组成原理/image-20231113115113217.png" alt="image-20231113115113217"></p>
<p><img src="/images/2023-11-13-计算机组成原理/image-20231113120219307.png" alt="image-20231113120219307"></p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>拼图游戏</title>
    <url>/2023/11/07/2023-11-7-%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="拼图游戏"><a href="#拼图游戏" class="headerlink" title="拼图游戏"></a>拼图游戏</h1><h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p>系统主要分为两个部分，初始界面和运行界面。</p>
<p>初始界面功能设计：</p>
<ol>
<li>展示图片（已完成）</li>
<li>展示标题（已完成）</li>
<li>点击图片进行拼图，即初始界面和运行界面的逻辑切换（已完成）</li>
</ol>
<p>运行界面功能设计：</p>
<ol>
<li>点击图片进行反馈（已完成）</li>
<li>点击两张不同的图片完成逻辑交换（已完成）</li>
<li>完成拼图后提示成功（已完成）</li>
<li>返回主界面功能（已完成）</li>
<li>计时功能</li>
</ol>
<h2 id="逻辑基本介绍"><a href="#逻辑基本介绍" class="headerlink" title="逻辑基本介绍"></a>逻辑基本介绍</h2><h3 id="一-图片的相关逻辑"><a href="#一-图片的相关逻辑" class="headerlink" title="一.图片的相关逻辑"></a>一.图片的相关逻辑</h3><h4 id="1-图片是如何存储的"><a href="#1-图片是如何存储的" class="headerlink" title="1. 图片是如何存储的"></a>1. 图片是如何存储的</h4><p>图片是采用qt中QPixmap类进行存储，同时使用万能数组<code>vector&lt;Qpixmap&gt;</code>来存储我们的图片。</p>
<h4 id="2-图片是如何展示的"><a href="#2-图片是如何展示的" class="headerlink" title="2. 图片是如何展示的"></a>2. 图片是如何展示的</h4><p>根据QPixmap的官方定义:</p>
<blockquote>
<h1 id="QPixmap-Class"><a href="#QPixmap-Class" class="headerlink" title="QPixmap Class"></a>QPixmap Class</h1><p>The QPixmap class is an off-screen image representation that can be used as a paint device.</p>
</blockquote>
<p><img src="/images/2023-11-7-拼图游戏/image-20231107085838372.png" alt="image-20231107085838372"></p>
<p>根据官方对QLabel中的方法setPixmap，可以使用QLabel来展示我们的图片。因此我们使用QPixmap来定义我们的图片。</p>
<h4 id="3-图片的顺序如何改变"><a href="#3-图片的顺序如何改变" class="headerlink" title="3. 图片的顺序如何改变"></a>3. 图片的顺序如何改变</h4><p>因为我们实现的是一个拼图游戏，因此我们需要不断地打乱拼图的顺序，我们使用一个数组来记录图片的顺序，再根据数组的顺序对图片进行一个个展示。</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231107091258197.png" alt="image-20231107091258197"></p>
<p>其中，<code>shuffle_order</code>即为我们打乱之后的数组顺序，<code>shuffle_order = &#123;1, 3, 5, 6, 9 ...&#125;</code>即一个n的permutation,以它的顺序作为标准,则可以按照我们想要的标准对图片进行展示。</p>
<h3 id="二-游戏运行逻辑"><a href="#二-游戏运行逻辑" class="headerlink" title="二.游戏运行逻辑"></a>二.游戏运行逻辑</h3><h4 id="图片的交换"><a href="#图片的交换" class="headerlink" title="图片的交换"></a>图片的交换</h4><p>由图片的展示可知，我们图片的展示顺序是通过一个数组来实现的，那么我们对图片进行交换其实就是对数组中的两个数字进行交换，直接使用<code>swap</code>函数即可。</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231107092659603.png" alt="image-20231107092659603"></p>
<h4 id="成功逻辑的判断"><a href="#成功逻辑的判断" class="headerlink" title="成功逻辑的判断"></a>成功逻辑的判断</h4><p>我们需要在每次交换图片之后都对游戏成功与否进行判断，并且在游戏成功之后给出提示（使用<code>messageBox</code>）。前面提到图片的展示顺序是通过一个数组实现的，因此我们只需要判断这个数组是否达到正序即可。</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231107092611738.png" alt="image-20231107092611738"></p>
<h4 id="图片选中效果的展示"><a href="#图片选中效果的展示" class="headerlink" title="图片选中效果的展示"></a>图片选中效果的展示</h4><p>图片的选中即对label的属性进行修改（如添加边框，图片减小等等操作），使用<code>setStyleSheet</code>方法，值得注意的是，我们在对执行交换操作时将label的样式改了回去。</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231107092826615.png" alt="image-20231107092826615"></p>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="1-初始界面点击图片进行拼图，即初始界面和运行界面的逻辑切换"><a href="#1-初始界面点击图片进行拼图，即初始界面和运行界面的逻辑切换" class="headerlink" title="1.初始界面点击图片进行拼图，即初始界面和运行界面的逻辑切换"></a>1.初始界面点击图片进行拼图，即初始界面和运行界面的逻辑切换</h3><p>要切换初始界面到运行界面不难，困难的是告诉运行界面我需要拼的是哪一张图。首先，我们需要了解事件过滤器的概念，官方对于事件过滤器的定义是这样的。</p>
<blockquote>
<p>The <a href="https://doc.qt.io/qt-6/qobject.html#installEventFilter">QObject::installEventFilter</a>() function enables this by setting up an <em>event filter</em>, causing a nominated filter object to receive the events for a target object in its <a href="https://doc.qt.io/qt-6/qobject.html#eventFilter">QObject::eventFilter</a>() function. An event filter gets to process events before the target object does, allowing it to inspect and discard the events as required. An existing event filter can be removed using the <a href="https://doc.qt.io/qt-6/qobject.html#removeEventFilter">QObject::removeEventFilter</a>() function.</p>
</blockquote>
<p>即我们可以通过<code>installEventFilter()</code>来设置一个事情过滤器，并且指定一个过滤事件来为我们的目标对象接受一个过滤事件，并且在事件发往目标目标对象前进行截获，<strong>执行我们需要的操作</strong>，并且可以在后续的代码中使用<code>removeEventFilter()</code>来移除这个事件过滤器。</p>
<p>通过事件过滤器，我们可以对我们的label标签进行操作（label标签本身不像button那样有一个<code>clicked()</code>信号槽），为label安装一个过滤器，写入当点击label时执行的函数，如生成一个运行窗口类，隐藏一个主界面，用于实现逻辑上的切换界面。</p>
<p>为了实现如何告知子窗口我们需要拼的是哪一张图片，我们需要了解信号与槽的概念。</p>
<blockquote>
<p>In GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a <strong>Close</strong> button, we probably want the window’s <a href="https://doc.qt.io/qt-6/qwidget.html#close">close</a>() function to be called.</p>
</blockquote>
<p>“‘当我们切换一个界面时，我们通常想要另外一个界面被告知。更加普遍的是，我们想要任何的类之间能够进行相互通讯。”官方这段介绍很好的描述了我们目前需要的机制，即切换界面，告知另一个界面我们需要哪个图片。</p>
<p>这种机制被称作<strong>信号与槽</strong>。</p>
<p><img src="/images/2023-11-7-拼图游戏/abstract-connections.png" alt="img"></p>
<p>我们需要在我们的初始界面的类中写一个信号，并且在运行界面的类中写一个槽用于接收这个信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">init_ui.h：</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPath</span><span class="params">(string s)</span></span>;</span><br><span class="line"></span><br><span class="line">puzzle.h:</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function">string <span class="title">receivePath</span><span class="params">(string s)</span></span>;</span><br><span class="line"></span><br><span class="line">puzzle.cpp:</span><br><span class="line"><span class="comment">// connect the signals and slots;</span></span><br><span class="line"><span class="built_in">connect</span>(init_ui, <span class="built_in">SIGNAL</span>(<span class="built_in">sendPath</span>(string s)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">receivePath</span>(string s)));    </span><br></pre></td></tr></table></figure>
<p>值得注意的是，第一个参数不能仅仅写为<code>init_ui</code>这个类，而是应该以实例化对象传入，因此我们可以在初始界面完成创建这个实例化对象，并且换成信号与槽的绑定。实际操作如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- init_ui.h:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	puzzle *er;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendPath</span><span class="params">(string s)</span></span>;</span><br><span class="line"></span><br><span class="line">- init_ui.cpp:</span><br><span class="line">er = <span class="keyword">new</span> <span class="built_in">puzzle</span>();</span><br><span class="line">QObject::<span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">sendPath</span>(string)), er, <span class="built_in">SLOT</span>(<span class="built_in">receivePath</span>(string)));</span><br><span class="line"></span><br><span class="line">- puzzle.h:</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receivePath</span><span class="params">(string s)</span></span>;</span><br><span class="line">    </span><br><span class="line">-puzzle.cpp:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">puzzle::receivePath</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;接受信号&quot;</span> &lt;&lt; endl;</span><br><span class="line">    QString qstr2 = QString::<span class="built_in">fromStdString</span>(s);</span><br><span class="line">    originalPixmap.<span class="built_in">load</span>(qstr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-游戏界面返回"><a href="#2-游戏界面返回" class="headerlink" title="2.游戏界面返回"></a>2.游戏界面返回</h3><p>在游戏的<code>ui</code>界面添加返回按钮，在游戏的头文件中创建主界面类，在点击返回按钮时，主界面的类出现，原来的类隐藏。</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231114082306342.png" alt="image-20231114082306342"></p>
<p>在使用的时候出现了一个相对来说比较绕的bug，即C++的循环引用，因此打开<code>visual studio</code>进行实验。</p>
<p><strong>BUG复现</strong></p>
<p>首先定义创建两个类</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231114101955433.png" alt="image-20231114101955433"></p>
<p>在a类中引用b，在b类中引用a，我们尝试编译。</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231114102450651.png" alt="image-20231114102450651"></p>
<p><strong>问题分析</strong></p>
<p>实际上是我们的主函数在运行时引用了<code>&quot;a.h&quot;</code>，而<code>&quot;a.h&quot;</code>中又引用了<code>&quot;b.h&quot;</code>，然后<code>&quot;b.h&quot;</code>又引用了<code>&quot;a.h&quot;</code>…导致了循环引用。我们尝试前置对类进行前置声明。</p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231114103909199.png" alt="image-20231114103909199"></p>
<p>又会出现一个新的bug，使用了未定义的”class a”，因为前置声明中仅仅只是包含对于类的声明，因此我们在类中进行实例化对象的时候会出现相应的报错，所以我们实例化的对象应该修改为指针，让内存为其分配一个地址，具体的实现可以在源文件中去做，这样可以避免问题的出现。</p>
<p><strong>成功解决</strong></p>
<p><img src="/images/2023-11-7-拼图游戏/image-20231114104127007.png" alt="image-20231114104127007"></p>
]]></content>
      <categories>
        <category>课程</category>
        <category>程序设计综合实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>程序设计综合实践</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>gpt</title>
    <url>/2023/11/08/2023-11-8-gpt/</url>
    <content><![CDATA[<h1 id="GPT-develop"><a href="#GPT-develop" class="headerlink" title="GPT develop"></a>GPT develop</h1><p><strong>What can gpt do?</strong></p>
<p><img src="/images/2023-11-8-gpt/image-20231109152404150.png" alt="image-20231109152404150"></p>
<p>Nowadays, the chatGpt can do a lot of things like Grammar correction, Emoji Translation and so on. You can visit the examples in the <a href="https://platform.openai.com/examples">openai</a>.</p>
<h2 id="0-Use-it"><a href="#0-Use-it" class="headerlink" title="0. Use it."></a>0. Use it.</h2><p>A easy example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line">client = OpenAI()</span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">  messages=[</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You will be provided with a message, and your task is to respond using emojis only.&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;How are you?&quot;</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  temperature=<span class="number">0.8</span>,</span><br><span class="line">  max_tokens=<span class="number">256</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(response.choices[<span class="number">0</span>].message)</span><br></pre></td></tr></table></figure>
<p>then the system will call back:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ChatCompletionMessage(content=<span class="string">&#x27;😊&#x27;</span>, role=<span class="string">&#x27;assistant&#x27;</span>, function_call=<span class="literal">None</span>, tool_calls=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>Like what you see, It’s very easy to use it! As we can interact with the API through HTTP requests from any language, via openai’s official Python bindings, official Node.js library, or a community-maintained library.</p>
<p>Before use the api, you should access your own api key(which is a secret for the public), then set it in your system environment so the program can call it and finish the authentication. You can also have a try at the <a href="https://platform.openai.com/playground?mode=chat">playground</a> like this.</p>
<p><img src="/images/2023-11-8-gpt/image-20231109155658333.png" alt="image-20231109155658333"></p>
<p>Let me introduce some prams in this page.</p>
<p><strong>temperature:</strong> control randomness, when the temperature comes to zero, you may find the answer deterministic.<br><strong>Maximum length:</strong> the maximum number of tokens.<br>Stop sequences: up to four sequences where the api will stop generating more tokens.<br><strong>Top P:</strong> maybe the top-k sampling can explain it more reasonably. At each time step of decoding, the words with the highest probability of the first k are sampled by their probability. But how to chose a valid K?</p>
<blockquote>
<p>The key intuition of Nucleus Sampling is that the vast majority of probability mass at each time step is concentrated in the nucleus, a small subset of the vocabulary that tends to range between one and a thousand candidates.</p>
</blockquote>
<p><strong>Frequency penalty:</strong> decrease the model’s likelihood to repeat the line verbatim.</p>
<p><strong>Presence penalty:</strong>  decrease the model’s likelihood to repeat the line verbatim based on the words appeared before in the sentence.</p>
<p>“Tokens” appeared server times that you should pay attention to, Text generation and embeddings models process text in chunks called tokens. A long word can be separated as several words. <code>congratulation -&gt; con gr at ulation</code>, this is a easy example. The Generative Pre-Training process the text using <strong>tokens</strong>.</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p><img src="/images/2023-11-8-gpt/image-20231109163310069.png" alt="image-20231109163310069"></p>
<p>There are a lot of you can choose. Based on your application, you can train your own models by <code>fine-tuning</code>.</p>
<blockquote>
<p>OpenAI’s text generation models have been pre-trained on a vast amount of text. To use the models effectively, we include instructions and sometimes several examples in a prompt. Using demonstrations to show how to perform a task is often called “few-shot learning.”</p>
</blockquote>
<p>You need prepare the dataset. Like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;Marv is a factual chatbot that is also sarcastic.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;What&#x27;s the capital of France?&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Paris, as if everyone doesn&#x27;t know that already.&quot;&#125;]&#125;</span><br><span class="line">&#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;Marv is a factual chatbot that is also sarcastic.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Who wrote &#x27;Romeo and Juliet&#x27;?&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Oh, just some guy named William Shakespeare. Ever heard of him?&quot;&#125;]&#125;</span><br><span class="line">&#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;Marv is a factual chatbot that is also sarcastic.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;How far is the Moon from Earth?&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Around 384,400 kilometers. Give or take a few, like that really matters.&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>Given some conversations, then you can create for a dataset.  Commonly the size of dataset is range from 50 to 100.</p>
<p>Before starting training, I recommend you read the <a href="https://platform.openai.com/docs/guides/fine-tuning/preparing-your-dataset">official documents</a>. </p>
<p>Then you can start train.</p>
<blockquote>
<p>tips: official support a <a href="https://platform.openai.com/finetune">fine-tuning UI</a></p>
</blockquote>
<p><strong>1. upload a training file</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line">client.files.create(</span><br><span class="line">  file=<span class="built_in">open</span>(<span class="string">&quot;mydata.jsonl&quot;</span>, <span class="string">&quot;rb&quot;</span>),</span><br><span class="line">  purpose=<span class="string">&quot;fine-tune&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># training file</span></span><br><span class="line">FileObject(<span class="built_in">id</span>=<span class="string">&#x27;file-BUNsqvioguXpT13xm6joN5z3&#x27;</span>, <span class="built_in">bytes</span>=<span class="number">783</span>, created_at=<span class="number">1699522826</span>, filename=<span class="string">&#x27;test_train.jsonl&#x27;</span>, <span class="built_in">object</span>=<span class="string">&#x27;file&#x27;</span>, purpose=<span class="string">&#x27;fine-tune&#x27;</span>, status=<span class="string">&#x27;processed&#x27;</span>, status_details=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><strong>2. Create a fine-tuned model</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line">client.fine_tuning.jobs.create(</span><br><span class="line">  training_file=<span class="string">&quot;file-abc123&quot;</span>, <span class="comment"># the ID that was returned when the training file was uploaded to the Open AI API.</span></span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo&quot;</span> <span class="comment"># model</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wrong...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2023/11/9 GPT down.</p>
</blockquote>
]]></content>
      <categories>
        <category>gpt</category>
      </categories>
      <tags>
        <tag>gpt</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP</title>
    <url>/2023/11/15/2023-11-15-CSAPP/</url>
    <content><![CDATA[<p><strong>内容提纲</strong></p>
<ul>
<li>第一章：计算机系统漫游</li>
<li>第二章：信息的表示和处理</li>
<li>第三章：程序的机器级表示</li>
<li>第四章：处理器体系结构</li>
<li>第五章：优化程序性能</li>
<li>第六章：存储器层次结构</li>
<li>第七章：链接</li>
<li>第八章：异常控制流</li>
<li>第九章：虚拟内存</li>
<li>第十章：系统级I/O</li>
<li>第十一章：网路编程</li>
<li>第十二章：并发编程</li>
</ul>
<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;heelo, world\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h2><p><img src="/images/2023-11-15-CSAPP/image-20231115153648187.png" alt="image-20231115153648187"></p>
<p>我们可以看到，对于这个hello.c的文件，可以用一系列的ASCII码来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。</p>
<p>像hello.c这样只有ASCII字符构成的文件成为文本文件，所有其它的文件都称为二进制文件。</p>
<h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p>为了在系统上能够运行hello.c程序，每条C语言都必须被其它程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行文件</strong>。</p>
<p>在Unix系统上，从源文件到目标文件的转化是由<strong>编译器驱动程序</strong>完成的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>翻译的过程需要依赖编译系统（compilation system）：预处理器、编译器、汇编器和链接器。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115154326084.png" alt="image-20231115154326084"></p>
<ul>
<li><p>预处理阶段：预处理器（cpp）根据以字符<code>#</code>开头的命令，修改原始的C程序。比如说将<code>#include &lt;stdio.h&gt;</code>命令告诉预处理器读取系统头未见<code>stdio.h</code>的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以<code>.i</code>作为文件扩展名。</p>
</li>
<li><p>编译阶段：编译器（ccl）将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含了一个汇编语言程序。该程序包含函数<code>main</code>的定义，如下所示：</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115154755442.png" alt="image-20231115154755442"></p>
<p>这里的每条语句都以一种文本格式描述了一条低级机器语言指令。<strong>汇编语言为不同高级语言的不同编译器提供了通用的输出语言</strong>。C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。</p>
</li>
<li><p>汇编阶段：汇编器（as）将<code>hello.s</code>翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件<code>hello.o</code>中，将看到一堆乱码。</p>
</li>
<li><p>链接阶段：<code>hello</code>程序调用了<code>printf</code>函数，它是每个C编译器都提供的标准C库中的一个函数。<code>printf</code>函数存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这种文件必须以某种方式合并到我们的<code>hello.o</code>程序中。链接器（ld）就负责处理这种合并。结果就得到<code>hello</code>文件，它是一个<strong>可执行目标文件</strong>，可以被加载到内存中，由系统执行。</p>
</li>
</ul>
<p><img src="/images/2023-11-15-CSAPP/image-20231115160426351.png" alt="image-20231115160426351"></p>
<h2 id="1-3-了解编译系统如何工作是大有益处的"><a href="#1-3-了解编译系统如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统如何工作是大有益处的"></a>1.3 了解编译系统如何工作是大有益处的</h2><ul>
<li>优化程序性能：<code>for</code>和<code>while</code>，<code>switch</code>和<code>if-else</code></li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞</li>
</ul>
<h2 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h2><p>在Unix系统上运行文件，将它的文件名输入到称为shell的应用程序中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux&gt; ./hello</span><br><span class="line">hello, world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><ol>
<li>总线：贯穿整个系统的是一组电子管道，携带信息字节并负责在各个部件间传递。</li>
<li>I/O设备：输入输出设备是系统与外部世界的联系通道。</li>
<li>主存：临时存储设备。</li>
<li>处理器：加载、存储、操作、跳转<br>指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</li>
</ol>
<h3 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h3><p>初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”./hello”后，shell程序将字符<strong>逐一读入寄存器</strong>，再把它放到内存中，如图1-5所示。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115161538588.png" alt="image-20231115161538588"></p>
<p>当我们在键盘上敲击回车键时，shell程序就知道我们<strong>已经结束了命令的输入</strong>。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello，world\n”。</p>
<p>利用<strong>直接存储器读取（DMA）技术</strong>，数据可以不通过处理器而直接从磁盘到达主存，这个步骤如图1-6所示。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115161901605.png" alt="image-20231115161901605"></p>
<p>一旦目标hello中的代码被加载到主存中，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello, world\n”字符串中的字节从<strong>主存复制到寄存器文件</strong>，再从寄存器文件复制到显示设备，最终显示在屏幕上。这个步骤如图1-7所示。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115162133297.png" alt="image-20231115162133297"></p>
<h2 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h2><p>如上图所示，在执行一个程序的过程中，系统需要反反复复、花费大量时间把信息从一个地方挪到另外一个地方（复制），这些“复制”就是开销。</p>
<p>因此采用了高速缓存存储器（cache memory，简称为cache或者高速缓存），作为暂时的集结区域。如图1-8所示，位于处理器芯片上的<strong>L1高速缓存</strong>的容量可以达到数万字节，访问速度几乎和访问俱存其文件一样快。一个容量为数十万到数百万字节的更大的<strong>L2高速缓存</strong>通过一条特殊的总线连接到处理器。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115162626929.png" alt="image-20231115162626929"></p>
<h2 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h2><p><img src="/images/2023-11-15-CSAPP/image-20231115162857859.png" alt="image-20231115162857859"></p>
<p>存储器层次结构的主要思想是上一层的存储器作为第一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存。</p>
<h2 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h2><p>当shell加载和运行hello程序时，shell和hello程序都没有直接访问我们的键盘、显示器、磁盘或主存。取而代之的是，他们依靠<strong>操作系统</strong>提供的服务。</p>
<p>操作系统的两个基本功能：1.防止硬件被失控的应用程序滥用。 2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个抽象的概念来实现这个目标（进程、虚拟内存和文件）。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115163137232.png" alt="image-20231115163137232"></p>
<h3 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h3><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在<strong>独占</strong>地使用硬件。</p>
<p><strong>并发运行</strong>：一个进程的指令和另一个进程的指令是<strong>交错执行</strong>的。这种<strong>交错执行</strong>的机制被称为<strong>上下文切换</strong>。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115163709275.png" alt="image-20231115163709275"></p>
<h3 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h3><p>现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据。</p>
<h3 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h3><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。<img src="/images/2023-11-15-CSAPP/image-20231115164255260.png" alt="image-20231115164255260"></p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p>
<ul>
<li>程序代码和数据：对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。</li>
<li>堆：代码和数据区后紧随着的是运行时堆。</li>
<li>共享库：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li>栈：位于用户虚拟地址空间顶部的是用户栈，用户栈在程序执行器期间可以动态地扩展和收缩。</li>
<li>内核虚拟内存：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，他们必须调用内核来执行这些函数。</li>
</ul>
<h3 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h3><p>文件就是字节序列。</p>
<h2 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h2><p>（计算机网络）从一个单独的系统来看，网络可视为一个I/O设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其它机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115164833792.png" alt="image-20231115164833792"></p>
<p><img src="/images/2023-11-15-CSAPP/image-20231115164924318.png" alt="image-20231115164924318"></p>
<h2 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h2><p>系统不仅仅只是硬件。</p>
<h3 id="1-9-1-Amdahl定律"><a href="#1-9-1-Amdahl定律" class="headerlink" title="1.9.1 Amdahl定律"></a>1.9.1 Amdahl定律</h3><p>Amdahl’s law，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速成都。若系统执行某应用程序需要时间为$T<em>{old}$。假设系统某部分所需执行时间与该时间的比例为$a$, 而该部分性能提升比例为$k$。即该部分初始所需时间为$aT</em>{old}$，现在所需时间为$aT_{old}/k$。因此，总的执行时间应该为：</p>
<script type="math/tex; mode=display">T_{new}=(1-a)T_{old}+aT_{old}/k=T_{old}[(1-a)+a/k]</script><p>由此可以计算加速比$s=T<em>{old}/T</em>{new}$为</p>
<script type="math/tex; mode=display">S=\frac{1}{1-a+a/k}</script><p>虽然我们对系统的一个主要部分做出了重大改进，但是活得系统加速比却明显小于这部分的加速比。这就是Amdahl定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p>
<h3 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h3><ol>
<li><p>线程级并发：构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。在过去，单核CPU在多个线程之间快速切换来达到并发的效果；随着多核处理器和<strong>超线程（hyperthreading）</strong>的出现，这种系统才变得常见。<br><img src="/images/2023-11-15-CSAPP/image-20231115170539861.png" alt="image-20231115170539861"></p>
<p>超线程，有时被称为同时多线程(simultaneous multi-threading)，是一项允许一个CPU执行多个控制流的技术。</p>
</li>
<li><p>指令集并发：在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。</p>
</li>
<li><p>单指令、多数据并行：在最低层次上，许多现代从处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作。</p>
</li>
</ol>
<h3 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h3><p>应用程序接口（API）、指令集架构、文件、虚拟内存、进程、虚拟机…</p>
<h1 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h1><p>现代计算机存储和处理的信息以二值信号表示，或称为位（bit）。</p>
<h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><p>大部分计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单元。</p>
<p>机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存（virtual memory）</strong>。</p>
<p>内存的每个字节都由一个唯一的数字来标识，称为它的<strong>地址（address）</strong>，所有可能地址的集合就称为<strong>虚拟地址空间（virtual address space）</strong>。</p>
]]></content>
      <categories>
        <category>课程</category>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CUMT计算机组成原理</title>
    <url>/2023/12/20/2023-12-20-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="第一章-计算机系统概论"><a href="#第一章-计算机系统概论" class="headerlink" title="第一章 计算机系统概论"></a>第一章 计算机系统概论</h2><h3 id="计算机的发展简史"><a href="#计算机的发展简史" class="headerlink" title="计算机的发展简史"></a>计算机的发展简史</h3><h4 id="五代变化"><a href="#五代变化" class="headerlink" title="五代变化"></a>五代变化</h4><ol>
<li>电子管计算机</li>
<li>晶体管计算机</li>
<li>中小规模集成电路计算机</li>
<li>大规模、超大规模集成电路计算机</li>
<li>巨大规模集成电路计算机</li>
</ol>
<h2 id="第二章-运算方法和运算器"><a href="#第二章-运算方法和运算器" class="headerlink" title="第二章 运算方法和运算器"></a>第二章 运算方法和运算器</h2><h3 id="数据和文字的表示方法"><a href="#数据和文字的表示方法" class="headerlink" title="数据和文字的表示方法"></a>数据和文字的表示方法</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><ol>
<li><p>定点数：固定小数点的位置<br>通常用<strong>纯小数</strong>或者<strong>纯整数</strong>来表示，如：</p>
</li>
<li><pre><code># 纯整数
100(D) = 01100100(B)
# 纯小数
0.125(D) = 0.00100000(B)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 对于数字$x_&#123;n&#125;x_&#123;n-1&#125;x_&#123;n-2&#125;x_&#123;n-3&#125;...x_&#123;1&#125;x_&#123;0&#125;$，其中$x_&#123;n&#125;$代表了符号位，剩余的部分如果表示的是**纯整数**，其绝对值范围是$0 \leq \left| x \right| \leq 2^n-1$，剩余部分如果表示的是**纯小数**，其取值范围为$0 \leq \left| x \right| \leq 1 - 2^&#123;-n&#125;$。目前计算机多用于整数运算。</span><br><span class="line"></span><br><span class="line">4. 浮点数：小数点位置浮动</span><br><span class="line"></span><br><span class="line">5. $$</span><br><span class="line">   N=2^e.M</span><br><span class="line">   $$</span><br><span class="line"></span><br><span class="line">6. $M$称为浮点数的**尾数**，是一个纯小数，$e$是浮点数的比例因子，称为浮点数的**指数**，2则是**基数**，是一个常见的对二进制机器的记数。</span><br><span class="line">   ![image-20231220113752791](/images/2023-12-20-计算机组成原理/image-20231220113752791.png)</span><br><span class="line">   ![image-20231220113825935](/images/2023-12-20-计算机组成原理/image-20231220113825935.png)</span><br><span class="line"></span><br><span class="line">7. 阶符就是符号位，阶码对应指数，数符就是基数，尾数就是$M$。</span><br><span class="line"></span><br><span class="line">8. 浮点数的规格化表示就是尾数绝对值大于等于0.5，在形式上表现为$M=0.1...$，最高位1视为隐藏在小数点的左侧，提高数据表示的精度。</span><br><span class="line">   指数e=阶码-127（为什么要用127这个值，0~255是阶码能够表示的范围，为了表示负数阶码，-127~127为32位浮点型需要表示的阶码数字范围，通过增加一个bias，能够让所有的阶码在表示的时候都以正数的形式出现，比如说$$19.625 = 10011.101 = 1.0011101 * 2^4$$，4是他真实的指数值，4+127=131是它在内存中存储的值。</span><br><span class="line">   64位是1位符号位，11位指数，52位尾数，其符号位的偏置(Bias)为1023。</span><br><span class="line"></span><br><span class="line">9. 十进制数串：</span><br><span class="line"></span><br><span class="line">   - 字符串的表现形式：一个字节存放一个十进制的数位或符号位。</span><br><span class="line"></span><br><span class="line">   - 压缩的十进制数串形式：一个字节存放两个十进制的数位。</span><br><span class="line"></span><br><span class="line">#### 数的机器码表示</span><br><span class="line"></span><br><span class="line">1. 原码</span><br><span class="line"></span><br><span class="line">   - 简单理解：第一位为符号位，后面的按二进制串相加即可。</span><br><span class="line">   - 浮点数原码定义：阶码部分按照**定点整数**的方法进行编码；尾数部分按照**定点小数**的方法进行编码。</span><br><span class="line">   - 符号位：0为正，1为负。</span><br><span class="line">   - 不便于加减运算，故引入补码</span><br><span class="line"></span><br><span class="line">2. 补码</span><br><span class="line"></span><br><span class="line">   - 模的概念：模数，79-38和79+62的后两位数字是相同的，也就是说-38和+62在意义上是等价的，前提是对模为100成立。</span><br><span class="line">   - 溢出量是多少，模数就是多少。</span><br><span class="line">   - $$[x]_&#123;补&#125;=x+m(MOD M)$$，因此正数的补码和其本身一致。</span><br><span class="line">   - 0的补码只有一种形式。</span><br><span class="line">   - 转换方式：原码除符号位外按位取反+1</span><br><span class="line"></span><br><span class="line">   ![image-20231220144720895](/images/2023-12-20-计算机组成原理/image-20231220144720895.png)</span><br><span class="line"></span><br><span class="line">3. 反码</span><br><span class="line"></span><br><span class="line">   - 浮点数反码定义：阶码部分按照定点整数的方法进行编码；尾数部分按照定点小数的方法进行编码。</span><br><span class="line">   - 转换方式：除了符号位外，其余按位取反。</span><br><span class="line"></span><br><span class="line">#### 字符和字符串的编码</span><br><span class="line"></span><br><span class="line">1. ASCII码</span><br><span class="line">2. 汉字的编码表示</span><br><span class="line">   - 输入编码：数字编码、拼音码、字形编码等</span><br><span class="line">   - 机内编码：一般用两个字节来实现</span><br><span class="line">   - 输出编码：字模码</span><br><span class="line">3. 校验码</span><br><span class="line">   - 检错码：奇偶校验码，就是1的个数是奇数还是偶数。</span><br><span class="line">   - 纠错码：</span><br><span class="line">     - 海明码：多重求校验码</span><br><span class="line">     - 循环冗余校验码（计网中也有）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 定点加法、减法运算</span><br><span class="line"></span><br><span class="line">#### 定点补码加减法的实现</span><br><span class="line"></span><br><span class="line">![image-20231220145728617](/images/2023-12-20-计算机组成原理/image-20231220145728617.png)</span><br><span class="line"></span><br><span class="line">从$$[Y]_&#123;补&#125;$$到$$[-Y]_&#123;补&#125;$$可以这样理解：Y和-Y互为相反数，对于Y和-Y的原码，除了第一位符号位外其余都相同，将它们都转换为补码，其符号位为1的那个数字要将剩余的位按位取反+1，另一个不变，他们补码中的**符号位是不同的**，符号位取反，**剩余的数码位置可以通过按位取反+1的操作复原**。因此将每一位（包括符号位）取反且末位加1，即可实现$$[-Y]_&#123;补&#125;$$。</span><br><span class="line"></span><br><span class="line">#### ![image-20231220150933799](/images/2023-12-20-计算机组成原理/image-20231220150933799.png)溢出概念和检测方法</span><br><span class="line"></span><br><span class="line">当且仅当两数为同符号的时候才有可能溢出（如果两数异号，能够说明两数都没有达到溢出，和另一个数作用只能使他们溢出的程度减小）。</span><br><span class="line"></span><br><span class="line">因此溢出分为上溢（两个正数相加）和下溢（两个负数相加）。</span><br><span class="line"></span><br><span class="line">两种检测方式：</span><br><span class="line"></span><br><span class="line">1. 双符号位法（变形补码/模4补码）</span><br><span class="line"></span><br><span class="line">   - 溢出$$T = V_i \oplus V_&#123;i-1&#125;$$，两位符号位如果是**异号**，说明发生了溢出。</span><br><span class="line">   - **最高符号位**始终指示正确的符号。</span><br><span class="line"></span><br><span class="line">2. 单符号位法</span><br><span class="line"></span><br><span class="line">   - 最高有效位有进位而符号位没有进位，称为上溢；最高有效位无进位而符号位有进位，称为下溢。</span><br><span class="line"></span><br><span class="line">   - 即当且仅当最高有效位和符号位进位与否同步才没有发生溢出。</span><br><span class="line"></span><br><span class="line">   - 溢出$$V=C_f \oplus  C_0$$。</span><br><span class="line"></span><br><span class="line">     ![image-20231220152912872](/images/2023-12-20-计算机组成原理/image-20231220152912872.png)![image-20231220153004330](/images/2023-12-20-计算机组成原理/image-20231220153004330.png)如图所示的N位行波进位加法减法器的溢出位表达式为$$F=C_n \oplus C_&#123;n-1&#125;$$，也就是采用的单符号位法。</span><br><span class="line"></span><br><span class="line">     同时有一个方式控制线M，当M=0时，B和方式控制M经过一个与非门，输出和B的每一位相同；当M=1时，B和方式控制M经过一个与非门，输出和B的每一位相反，也就是将B的每一位取反，注意到第一位的进位输入$$C_0$$也是由M来控制的，M=1就会多加一个1，也就是B按位取反再加1，$$[-B]_&#123;补&#125;$$就求出来了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 定点乘法运算</span><br><span class="line"></span><br><span class="line">1. 原码并行乘法</span><br><span class="line">   运算规则：**符号位**和**数值部分（绝对值）**分别运算。</span><br><span class="line">   ![img](/images/2023-12-20-计算机组成原理/Fq8pX-WBOTLBgmljUsLrHQwlfFxi.png)</span><br><span class="line"></span><br><span class="line">2. 不带符号的阵列乘法器（主要）</span><br><span class="line">   增加全加器的个数，实现并行操作，提高速度。首先用”与“门，产生m×n个被加数&#123;$$&#123;a_ib_j|0\leq i \leq m - 1,0 \leq j \leq n - 1&#125;$$&#125;；再用阵列全加器，快速相加，实现乘法。</span><br><span class="line">   实现**n位乘n位**时，需要$$n(n-1)$$个全机器（FA）和n×n个”与“门。</span><br><span class="line">   ![image-20231220154429061](/images/2023-12-20-计算机组成原理/image-20231220154429061.png)</span><br><span class="line"></span><br><span class="line">3. 带符号的阵列乘法器</span><br><span class="line"></span><br><span class="line">   - **求补电路**的设计原理：求补实际上就是将所有位按位取反之后加1，也就是说它的最末位如果为0，求反+1之后会进位到第一个原来位置为1的位上。（剩余的前面的位置就直接取反即可）。</span><br><span class="line">     - 用符号位作为控制信号。</span><br><span class="line">     - 从最末位开始找到第一个1，该位以左全部求反，该位及以右的位不变。</span><br><span class="line"></span><br><span class="line">   ![image-20231220155554704](/images/2023-12-20-计算机组成原理/image-20231220155554704.png)</span><br><span class="line"></span><br><span class="line">   带符号的阵列乘法器核心还是乘法阵列器，先求出补码，最后把输出变成带符号的数（注意看左边的与非门，用于控制符号位）。</span><br><span class="line"></span><br><span class="line">#### 定点除法运算</span><br><span class="line"></span><br><span class="line">1. 计算机做除法有两个关键点，一是判断本次除法是否溢出，二是每次上商之前总是要做一次余数做减数的操作。</span><br><span class="line">2. 判断溢出：将被除数的高n位减去除数，若余数大于0，则本次运算溢出，立即终止，若余数小于0，则应将除数加回去恢复被除数，继续除法运算。</span><br><span class="line">3. 恢复余数法：每次上商之前总是要做一次余数做除数的操作，若余数大于或等于0，则表示够减，商1后应将该余数左移一位得到新余数，若余数小于0，则表示不够减，商0且本次运算不该做，应将除数加回去，恢复原来的余数后将其左移一位得到新余数。</span><br><span class="line"></span><br><span class="line">![image-20231220162235230](/images/2023-12-20-计算机组成原理/image-20231220162235230.png)</span><br><span class="line"></span><br><span class="line">恢复余数法，由于要恢复余数，使除法进行过程的步数不固定，因此控制比较复杂。实际中常用**不恢复余数法**，又称**加减交替法**。其特点是运算过程中如出现不够减，则**不必恢复余数**，根据余数符号可以继续往下运算从而简化运算。</span><br><span class="line"></span><br><span class="line">![image-20231220162455651](/images/2023-12-20-计算机组成原理/image-20231220162455651.png)</span><br><span class="line"></span><br><span class="line">简单来说，加减交替法：</span><br><span class="line"></span><br><span class="line">1. $$R_&#123;i + 1&#125; \geq 0$$，则商1，下次做$$2R_&#123;i+1&#125; - Y$$。</span><br><span class="line">2. $$R_&#123;i + 1&#125; \leq 0$$，则商0，下次做$$2R_&#123;i+1&#125; + Y$$。</span><br><span class="line"></span><br><span class="line">![image-20231220162657213](/images/2023-12-20-计算机组成原理/image-20231220162657213.png)</span><br><span class="line"></span><br><span class="line">![image-20231220164845852](/images/2023-12-20-计算机组成原理/image-20231220164845852.png)</span><br><span class="line"></span><br><span class="line">并行除法器</span><br><span class="line"></span><br><span class="line">1. 可控加法/减法单元：用于并行除法流水逻辑阵列中，有四个输出端和四个输入端。输入线P=0时，做加法；P=1时，做减法。</span><br><span class="line">   ![image-20231220165040836](/images/2023-12-20-计算机组成原理/image-20231220165040836.png)P用作控制，其A和B作为输入，C作为进位输入。通过真值表法可以得出上述表达式中的结果，根据该结果连接电路图即可。</span><br><span class="line"></span><br><span class="line">   ![image-20231220165100269](/images/2023-12-20-计算机组成原理/image-20231220165100269.png)</span><br><span class="line"></span><br><span class="line">#### 定点运算器的组成</span><br><span class="line"></span><br><span class="line">算术/逻辑运算单元、数据缓冲寄存器、通用寄存器、多路转换器和数据总线等。</span><br><span class="line"></span><br><span class="line">1. 多功能算术/逻辑运算单元：</span><br><span class="line">   行波进位加法器的缺点：串行进位，速度慢；只能完成加减运算而不能完成逻辑操作；</span><br><span class="line">   - 基本思想：输入通过**控制参数**$$S_0,S_1,S_2,S_3$$，形成**组合函数**$$X_i,Y_i$$，$$S_0S_1$$控制$$Y_i$$，$$S_2S_3$$控制$$X_i$$。</span><br><span class="line">     ![image-20231220171555721](/images/2023-12-20-计算机组成原理/image-20231220171555721.png)</span><br><span class="line">   - 用这样的算术单元能够对AB实现不同的操作，因此为后面先行进位操作提供了先决条件。</span><br><span class="line">     ![img](/images/2023-12-20-计算机组成原理/FnwLnepU96PcfkBXAkvqWxWOUuJK.png)</span><br><span class="line">2. 内部总线</span><br><span class="line">   按照总线所处的位置分为**内部**总线和**外部**总线，按照总线的逻辑结构，总线分为**单向、双向**传输总线。</span><br><span class="line">3. 定点运算器的基本结构</span><br><span class="line">   - 单总线结构的运算器：数据传输通过分时的方式。</span><br><span class="line">   - 双总线结构的运算器：两个操作数同时加到ALU进行运算，输出会先存到缓冲器，然后再通过总线输入到目的寄存器。</span><br><span class="line">   - 三总线结构的运算器：两个输入端分别由两条总线供给，ALU的输出和第三条总线相连。</span><br><span class="line"></span><br><span class="line">#### 浮点运算方法和浮点运算器</span><br><span class="line"></span><br><span class="line">1. 浮点加法、浮点减法</span><br><span class="line"></span><br><span class="line">   - 0操作数检查</span><br><span class="line">   - 比较阶码大小并完成对阶：对阶是阶码小的数向阶码大的数对齐。小阶的尾数右移ΔE位（减小精度损失）。</span><br><span class="line">   - 尾数进行加或减运算：和定点加减法是相同的</span><br><span class="line">   - 结果规格化：还是尾数的绝对值在0.5~1之间。左移规格化、右移规格化</span><br><span class="line">   - 舍入处理：“0舍1入”，“恒置1”，就近舍入、朝0舍入、朝正无穷舍入、朝负无穷舍入。</span><br><span class="line">   - 溢出处理：浮点数的溢出一般是阶码溢出。尾数上溢：右规；尾数下溢出：舍入。</span><br><span class="line"></span><br><span class="line">   ![img](/images/2023-12-20-计算机组成原理/Fo6mvBlsaAlcAZY5ElMiOMJ3qJdq.png)</span><br><span class="line"></span><br><span class="line">2. 浮点乘法、除法运算</span><br><span class="line"></span><br><span class="line">   - 0操作数检查</span><br><span class="line">   - 阶码加/减操作</span><br><span class="line">   - 尾数乘/除操作：对于除法，要先将尾数进行调整才可以进行运算。</span><br><span class="line">   - 结果规格化及舍入处理</span><br><span class="line"></span><br><span class="line">3. 浮点运算流水线</span><br><span class="line">   ![image-20231220174129693](/images/2023-12-20-计算机组成原理/image-20231220174129693.png)流水线浮点加法器</span><br><span class="line"></span><br><span class="line">   ![image-20231220174258679](/images/2023-12-20-计算机组成原理/image-20231220174258679.png)</span><br><span class="line"></span><br><span class="line">## 第三章 存储系统</span><br><span class="line"></span><br><span class="line">#### 分类、分级和性能指标</span><br><span class="line"></span><br><span class="line">存储器、存储介质、存储为或存储元、存储单元。</span><br><span class="line"></span><br><span class="line">**分类**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
存储介质：半导体存储器、光存储器、磁表面存储器
存取方式：随机、顺序/半顺序存储器
读写功能：读写、只读存储器
信息可保存性：非永久、永久性记忆的存储器
系统作用：主/辅助、高速缓冲/控制存储器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**分级**</span><br><span class="line"></span><br><span class="line">多级存储器体系结构：高速缓冲存储器（cache）、主存储器和外存储器。</span><br><span class="line"></span><br><span class="line">![image-20231221095614242](/images/2023-12-20-计算机组成原理/image-20231221095614242.png)</span><br><span class="line"></span><br><span class="line">内存：CPU可直接访问</span><br><span class="line"></span><br><span class="line">外存：调入内存中，才能被CPU处理</span><br><span class="line"></span><br><span class="line">几种常见电路：TTL门电路，存取速度快成本高，cache；MOS电路（PMOS，NMOS， CMOS），集成度高成本低，主存。</span><br><span class="line"></span><br><span class="line">**性能指标**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
主要：存储容量、存取时间、存储周期和存储器带宽、可靠性、功耗与集成度、性价比
字存储单元
字节存储单元
按字寻址的计算机
按字节寻址的计算机
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**存储芯片规格的表示**</span><br><span class="line"></span><br><span class="line">$$M×W$$,其中M使该芯片单元的总数，单位是兆。W是每个存储单元的容量，也就是SDRAM的位宽，单位是bit。</span><br><span class="line"></span><br><span class="line">&gt; SDRAM: Synchronous Dynamic Random Access Memory，同步动态随机存储器。同步是指其时钟频率和CPU前端总线的系统时钟相同，并且内部命令的发送与数据的传输都以它为基准；动态是指存储阵列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是自由指定地址进行数据的读写。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### RAM存储器</span><br><span class="line"></span><br><span class="line">RAM: Random Access Memory.</span><br><span class="line"></span><br><span class="line">优点：存取速度快、体积小、可靠性高、价格低</span><br><span class="line"></span><br><span class="line">缺点：掉电掉信息</span><br><span class="line"></span><br><span class="line">RAM分为SRAM(static)和DRAM(dynamic)。</span><br><span class="line"></span><br><span class="line">**存储元**</span><br><span class="line"></span><br><span class="line">- 由锁存器（触发器）构成</span><br><span class="line">- 在直流电供电的条件下，信息可保持，断电后信息丢失。</span><br><span class="line"></span><br><span class="line">**基本的静态存储元阵列**</span><br><span class="line"></span><br><span class="line">##### ![image-20231221100856648](/images/2023-12-20-计算机组成原理/image-20231221100856648.png)SRAM存储器构成</span><br><span class="line"></span><br><span class="line">- 由存储体、地址译码电路（把二进制代码表示的地址转换成输出端的高电位，来驱动相应的读写电路）、读写电路和控制电路、驱动器、I/O电路、片选与读写控制电路等构成。</span><br><span class="line"></span><br><span class="line">- SRAM多采用双译码方式，首先X、Y向独立译码，然后在存储阵列中完成交叉译码。</span><br><span class="line">- 读写互锁逻辑</span><br><span class="line">  ![image-20231221101350475](/images/2023-12-20-计算机组成原理/image-20231221101350475.png)</span><br><span class="line"></span><br><span class="line">**SRAM的读写周期**</span><br><span class="line"></span><br><span class="line">- 读周期：存储片进行两次连续读操作时所必须间隔的时间。</span><br><span class="line">  ![image-20231221101508282](/images/2023-12-20-计算机组成原理/image-20231221101508282.png)</span><br><span class="line"></span><br><span class="line">- 写周期：有效期间地址和数据信号不能变化。</span><br><span class="line">  ![image-20231221101651860](/images/2023-12-20-计算机组成原理/image-20231221101651860.png)</span><br><span class="line"></span><br><span class="line">- 存储器与CPU连接：传递地址、数据和控制信息</span><br><span class="line"></span><br><span class="line">  涉及到几种扩容方式：</span><br><span class="line"></span><br><span class="line">  - 位扩展法：字变长，字数不变。数据线条数增加，地址线条数不变。</span><br><span class="line">    ![image-20231221102012784](/images/2023-12-20-计算机组成原理/image-20231221102012784.png)</span><br><span class="line">  - 字扩展法：字数变多，字长不变。</span><br><span class="line">    ![image-20231221102031956](/images/2023-12-20-计算机组成原理/image-20231221102031956.png)</span><br><span class="line">  - 字位同时扩展法：$$M×N$$的芯片可由$$(M/l) × (N / k)$$个$$l×k$$的芯片的芯片扩充。</span><br><span class="line"></span><br><span class="line">- 地址分配与片选逻辑</span><br><span class="line">  存储器的寻址逻辑：芯片内的寻址系统（二级译码）+芯片外的&lt;u&gt;地址分配（用于寻找片内的存储单元）&lt;/u&gt;与&lt;u&gt;片选逻辑（用于寻找芯片）&lt;/u&gt;。</span><br><span class="line">  地位分配给芯片（如一个4KB的芯片需要12($$2^&#123;12&#125;$$)位地址寻址），高位用于形成片选逻辑（可以通过译码器进行扩展）。</span><br><span class="line"></span><br><span class="line">##### DRAM存储器</span><br><span class="line"></span><br><span class="line">DRAM的存储元通过一个MOS晶体管和电容器组成记忆电路。</span><br><span class="line"></span><br><span class="line">**特点**</span><br><span class="line"></span><br><span class="line">- 增加了行地址锁存器和列地址锁存器。DRAM存储器的容量很大，地址线宽度要相应的增加，这会增加芯片地址线的管脚数目。为了避免这种情况，采取分时传送地址码的方式，</span><br><span class="line">- 增加了刷新计数器和相应的控制电路。DRAM读出后必须刷新，未读写的存储原也要定期刷新，且按行刷新（因此刷新计数器的长度等于行地址锁存器）。</span><br><span class="line"></span><br><span class="line">**DRAM的读写周期**</span><br><span class="line"></span><br><span class="line">- 读周期</span><br><span class="line">  ![image-20231221104308178](/images/2023-12-20-计算机组成原理/image-20231221104308178.png)</span><br><span class="line">- 写周期</span><br><span class="line">  ![image-20231221104325154](/images/2023-12-20-计算机组成原理/image-20231221104325154.png)</span><br><span class="line"></span><br><span class="line">**DRAM的刷新周期**</span><br><span class="line"></span><br><span class="line">刷新周期：从上一次对整个存储器刷新结束到下一次对整个存储器全部刷新一遍为止，这一段时间间隔称为刷新周期。</span><br><span class="line"></span><br><span class="line">- 集中刷新方式：前一部分读/写周期或维持周期，后一部分只进行刷新操作。刷新过程中不能进行读写的操作，因此这一部分时间称为死时间。</span><br><span class="line">  ![image-20231221104611750](/images/2023-12-20-计算机组成原理/image-20231221104611750.png)</span><br><span class="line">- 分散刷新方式：每个一段时间刷新一行。</span><br><span class="line">  ![image-20231221104720192](/images/2023-12-20-计算机组成原理/image-20231221104720192.png)</span><br><span class="line"></span><br><span class="line">**分时复用地址线**</span><br><span class="line"></span><br><span class="line">行列地址的信号在发送的时候使用相同的地址线，通过选通信号来决定应该发送行还是列的地址信号。</span><br><span class="line"></span><br><span class="line">半导体静态RAM是靠**触发器原理**存储信息；半导体动态RAM靠**电容存储电荷原理**存储信息。</span><br><span class="line"></span><br><span class="line">存储器在进行读写操作时，首先必须先接受**地址**信号，再接受**片选和读写**信号，最后才在数据总线上进行信息交换。</span><br><span class="line"></span><br><span class="line">**高级的DRAM结构**</span><br><span class="line"></span><br><span class="line">1. FPM-DRAM：快速页模式动态存储器，根据程序的局部性原理实现。读周期和写周期中，为了寻找一个确定的存储单元地址，首先由低电平的行选通信号确定行地址，然后由低电平的列选信号确定列地址。下一次寻找操作，也是由行选通信号选定行地址，列选信号选定列地址，依次类推。**快速页模式允许在选定的行中对每一个列地址进行连续快速的读操作或写操作**。</span><br><span class="line">2. CDRAM：在DRAM芯片上进程一个SRAM实现的小容量高速缓冲器，以改善芯片性能。</span><br><span class="line">   - 在SRAM读出期间可以同时对DRAM阵列刷新。</span><br><span class="line">   - 芯片内的数据输出路径与数据的输入路径是分开的，允许在写操作完成的同时来启动同一行的读操作。</span><br><span class="line">   - 对猝发式读取非常有利。</span><br><span class="line">     ![image-20231221112105433](/images/2023-12-20-计算机组成原理/image-20231221112105433.png)</span><br><span class="line"></span><br><span class="line">**DRAM主存读/写的正确性校验**</span><br><span class="line"></span><br><span class="line">![image-20231221112408253](/images/2023-12-20-计算机组成原理/image-20231221112408253.png)若写入存储器前与读出存储器后两部分的F运算结果一致，则存储器读写正确，否则给出错误信号。F是奇校验或偶校验的异或运算电路。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 只读存储器和闪速存储器</span><br><span class="line"></span><br><span class="line">ROM: Read Only Memory，其最大的优点是具有非易失性。</span><br><span class="line"></span><br><span class="line">**ROM的分类**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
掩模式ROM(M):数据在芯片制造过程中已确定
一次编程ROM(PROM):熔丝烧断型PROM、PN结击穿型PROM
多次编程ROM:光擦编程ROM(EPROM),电擦编程ROM(EEPROM)
</code></pre></li>
<li><p>掩模ROM</p>
</li>
<li>可编程ROM<ol>
<li>EPROM<ul>
<li>存储0: G1栅有电子积累，该MOS管的开启电压变得很高，即使G2栅为高电平，该管仍不能导通，相当于存储了”0”；</li>
<li>存储1: G1栅无电子积累，MOS管的开启电压较低，当G2栅为高电平时，MOS管导通，相当于存储了“1”.</li>
<li>擦除: 当用光子能量较高的紫外光照射G1浮栅时，G1中电子获得足够能量，穿过氧化层回到衬底，使浮栅上的电子消失，抹去了信息。</li>
</ul>
</li>
<li>EEPROM<br>出厂时候存储的内容都是1，根据需要进行修改。</li>
</ol>
</li>
</ol>
<p><strong>FLASH存储器（Flash Memory）</strong></p>
<ol>
<li>特点<ul>
<li>固有的非易失性</li>
<li>廉价的高密度</li>
<li>直接执行</li>
<li>固态性能</li>
</ul>
</li>
<li>Flash存储器的基本操作<ul>
<li>编程操作：初始为1，写0就在控制栅上加正电压，为浮空栅补充电子。</li>
<li>读取操作：当MOS晶体管导通时，电源<script type="math/tex">V_D</script>提供从漏极D到源极S的电流，读出电路检测到电流则表示1，无电流则表示0。</li>
<li>擦除操作：采用电擦除，在源极加上正电压。</li>
</ul>
</li>
</ol>
<h4 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h4><p>CPU和存储器的速度不匹配，限制了高速计算。</p>
<p><strong>双端口存储器DPRAM</strong></p>
<ol>
<li><p><u>同一个存储器具有两组相互独立的读写控制线路。</u></p>
</li>
<li><p>无冲突读写控制：当两个端口的地址不同时，在两个端口上进行读写操作，一定不会发生冲突。</p>
</li>
<li>有冲突的读写控制：当两个端口同时存取同一存储单元时，便发生读写冲突，为此设置BUSY标志。由存储器的仲裁逻辑决定有线对哪个端口进行读写操作。另一个端口暂时关闭。</li>
</ol>
<p><strong>多模块交叉存储器</strong></p>
<ol>
<li>存储器的模块化组织</li>
<li>多模块交叉存储器的基本结构</li>
</ol>
<h4 id="cache存储器"><a href="#cache存储器" class="headerlink" title="cache存储器"></a>cache存储器</h4><p><strong>两个局部性原理</strong></p>
<ol>
<li>CPU对内存的访问在相对较短的时间间隔内往往集中于某个局部。</li>
<li>在一小段时间内，最近被访问过的程序和数据很大可能再次被访问。</li>
<li>解决这个问题，层次之间需要满足以下原则<ul>
<li>一致性原则：处在不同层次存储器中的同一信息应保持相同的值</li>
<li>包含性原则：存储在内层（靠近CPU）的信息一定被包含在其外层的存储介质中，反之不成立。</li>
</ul>
</li>
</ol>
<p><strong>cache的基本原理</strong></p>
<ol>
<li>把cache和主存分成若干大小相同的块</li>
<li>cache主要由块表和快速存储器组成</li>
<li>对主存地址，根据映象规则生成块号和候选位置</li>
<li>根据块号和侯选位置查找块表，无则到主存取数据（R<strong>替换策略</strong>，W<strong>写回策略</strong>）；有则生成cache地址，查快速存储器读写数据（W<strong>写回策略</strong>）</li>
<li>将从cache或主存取得得数据送处理器</li>
</ol>
<p>CPU和cache间得数据交换是以<strong>字</strong>为单位；cache与主存间的数据交换是以<strong>块</strong>为单位。</p>
<p><strong>cache的命中率</strong></p>
<p>设在一段程序执行期间，cache完成存取次数为<script type="math/tex">N_c</script>，主存完成存取次数为<script type="math/tex">N_m</script>，h定义为<u>命中率</u>，则<script type="math/tex">h=N_c/(N_c+N_m)</script>。</p>
<p><u>平均访问时间</u>：<script type="math/tex">t_a=ht_c+(1-h)t_m</script></p>
<p><u>访问效率</u>：<script type="math/tex">e=t_c/t_a=t_c/ht_c+(1-h)t_m=1/h+(1-h)r</script></p>
<p><strong>主存与cache的地址映射</strong></p>
<ol>
<li><p>地址映射：把主存地址定位到cache中的方法。<br>三种地址映象：</p>
<ul>
<li><p>直接相联</p>
</li>
<li><p>全相联方式</p>
<ul>
<li><p>规则：1).主存与缓存分成大小相同的数据块。2).主存的某一数据块可以装入缓存的任意一块的空间中。<br><img src="/images/2023-12-20-计算机组成原理/image-20231221171425516.png" alt="image-20231221171425516"></p>
<p><img src="/images/2023-12-20-计算机组成原理/image-20231221171446385.png" alt="image-20231221171446385"></p>
</li>
<li><p>转换公式：<br>主存地址长度=(s+w)位<br>寻址单位数=<script type="math/tex">2^w</script>个字或字节<br>块大小=行大小=<script type="math/tex">2^w</script>个字或字节<br>主存的块数=<script type="math/tex">2^s</script><br>标记大小=s位<br>cache的行数不由地址格式确定</p>
</li>
<li><p>特点<br>优点：冲突概率小，Cache的利用率高。<br>缺点：比较器难实现，需要一个访问速度很快代价高的相联存储器</p>
</li>
</ul>
</li>
<li><p>直接相联方式</p>
<ul>
<li><p>直接相联的地址映射规则：</p>
<ol>
<li>主存第<script type="math/tex">B_j</script>块内容拷贝到Cache的<script type="math/tex">L_i</script>行</li>
<li>i = j mod m</li>
<li><script type="math/tex; mode=display">m = 2^r$$, $$n=2^s</script></li>
</ol>
<p><img src="/images/2023-12-20-计算机组成原理/image-20231221195717407.png" alt="image-20231221195717407"><br><img src="/images/2023-12-20-计算机组成原理/image-20231221195741778.png" alt="image-20231221195741778"><br><img src="/images/2023-12-20-计算机组成原理/image-20231221195800811.png" alt="image-20231221195800811"></p>
<p>优点：</p>
<ul>
<li>硬件实现很简单，不需要相联访问存储器</li>
<li>访问速度也比较快，实际上不进行地址变换</li>
</ul>
<p>缺点：</p>
<ul>
<li>块的冲突率比较高</li>
</ul>
</li>
<li><p>组相联映射方式</p>
<ul>
<li>全相联映射和直接映射的优缺点刚好相反</li>
<li>将cache分成u组，每组v行。<script type="math/tex">m=u×v</script>。组号<script type="math/tex">q=j</script> <script type="math/tex">mod</script> <script type="math/tex">u</script>。</li>
<li>组间直接相联，组内全相联</li>
</ul>
<p><img src="/images/2023-12-20-计算机组成原理/image-20231221200525132.png" alt="image-20231221200525132"><br><img src="/images/2023-12-20-计算机组成原理/image-20231221200535784.png" alt="image-20231221200535784"></p>
</li>
<li><p>转换公式<br>主存地址长度=(s+w)位<br>寻址单元数=<script type="math/tex">2^{s+w}</script>个字或字节<br>块大小=行大小=<script type="math/tex">2^w</script>个字或字节<br>cache组数<script type="math/tex">u=2^d</script><br>标记大小=(s - d)位<br><img src="/images/2023-12-20-计算机组成原理/image-20231221201312052.png" alt="image-20231221201312052"></p>
</li>
</ul>
</li>
</ul>
<p><strong>替换策略</strong></p>
<ol>
<li>最不经常使用算法LFU(Least Frequently Used): 一段时间内被访问次数最少的那一行。</li>
<li>近期最少使用算法LRU(Least Recently Used): 近期内长久未被访问过的行换出。</li>
<li>随机替换</li>
</ol>
<p><strong>cache的写操作策略</strong></p>
<ol>
<li>写回法：当写cache命中时，只修改cache的内容，<strong>而不立即写入主存</strong>；当写cache未命中时，把此块替换到cache中修改；写主存统一留到此行被换出时进行。</li>
<li>全写法：当写cache命中时，cache和主存同时写修改；当写cache未命中时，直接写入主存。但是否把修改过的主存块取到cache中，有两种选择：一是取主存块到cache并为它分配一行位置；另一是不取主存块到cache。</li>
<li>写一次法：写cache命中与未命中时和写回法基本相同，只是在<strong>第一次写命中时要写入主存</strong>。</li>
</ol>
</li>
</ol>
<h2 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h2><p>指令系统又叫指令集(Instruction Set)，是计算机体系结构设计的核心，是计算机软、硬件接口，是用机器语言、汇编语言编写程序的用户所能看到的计算机的基本属性。</p>
<h4 id="指令系统的发展"><a href="#指令系统的发展" class="headerlink" title="指令系统的发展"></a>指令系统的发展</h4><h5 id="复杂指令集计算机"><a href="#复杂指令集计算机" class="headerlink" title="复杂指令集计算机"></a>复杂指令集计算机</h5><p><strong>CISC(Complex Instruction Set Computer)</strong></p>
<script type="math/tex; mode=display">T_{cpu}=I_N×CPI×T_c</script><p>CISC是通过减少<script type="math/tex">I_N</script>值来减少<script type="math/tex">T_{cpu}</script>的</p>
<p>其中<script type="math/tex">T_c</script>: 表示时钟周期。 <script type="math/tex">I_N</script>: 表示CPU执行某一程序中所包含的指令总数。<script type="math/tex">CPI</script>: 表示执行每条指令所需的平均时钟周期数</p>
<p>特点</p>
<ol>
<li>指令系统复杂，指令数多，寻址方式多，指令格式多</li>
<li>绝大多数指令需要多个机器时钟周期方可完成</li>
<li>各种指令都可以访问存储器</li>
<li>采用微程序控制</li>
<li>有专用寄存器</li>
<li>难以用优化编译生成高效的目标代码程序</li>
</ol>
<h5 id="精简指令集计算机"><a href="#精简指令集计算机" class="headerlink" title="精简指令集计算机"></a>精简指令集计算机</h5><p><strong>RISC(Reduced Instruction Set Computer)</strong></p>
<script type="math/tex; mode=display">T_{cpu}=I_N×CPI×T_c</script><p><u>RISC是通过减少CPI值，简化结构来减少<script type="math/tex">T_{cpu}</script>。</u></p>
<p>特点</p>
<ol>
<li>精简指令系统</li>
<li>以寄存器-寄存器方式工作，除了load/Store指令访问存储器外，其余指令只访问寄存器</li>
<li>除了Load/Store指令访问寄存器外，所有指令在一个机器时钟周期完成，并采用流水线技术</li>
<li>使用较多的通用寄存器，一般至少32个，不允许有专用寄存器</li>
<li>大多采用硬联线控制，少用或不用微程序实现</li>
</ol>
<h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p>指令的一般结构形式：操作码字段（表示指令的操作特性与功能）+地址码字段（通常用于指定参与操作的操作数地址）</p>
<h5 id="指令字长度"><a href="#指令字长度" class="headerlink" title="指令字长度"></a>指令字长度</h5><ul>
<li>指令的长度是指一条指令所包含二进制代码的位数，取决于操作码长度和操作数地址个数及每个地址的长度。</li>
<li>机器字长：计算机能直接处理的二进制数据的位数</li>
<li>指令长度与机器字长的关系：半字长指令，单字长指令，双字长指令</li>
</ul>
<h5 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h5><p>定长编码，变长编码</p>
<h5 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h5><ol>
<li>零地址指令</li>
<li>一地址指令</li>
<li>二地址指令</li>
<li>三地址指令</li>
<li>指令助记符</li>
</ol>
<h5 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h5><p>地址数据、数值数据、字符数据、逻辑数据</p>
<h5 id="指令和数据的寻址地址"><a href="#指令和数据的寻址地址" class="headerlink" title="指令和数据的寻址地址"></a>指令和数据的寻址地址</h5><p>寻址方式：采用地址指定方式时，形成操作数地址或指令地址的方式、指令寻址方式、数据寻址方式</p>
<ol>
<li><p>指令寻址方式：</p>
<ul>
<li>顺序寻址方式：程序指令按顺序存在内存中，然后顺序读出。</li>
<li>跳跃寻址方式：程序要执行的指令的地址由上一个指令的地址码给出。</li>
</ul>
</li>
<li><p>操作数寻址方式：</p>
<p>例子：单地址：操作码+变址+间址+形式地址（偏移量，逻辑地址）—&gt;有效地址：真实地址，物理地址<br>有效地址由形式地址和寻址方式特征位等共同确定，实际上就是将形式地址转化为有效地址</p>
<ul>
<li>隐含寻址(Implied Addressing)：不明显指定操作数的地址，在指令中隐含着操作数的地址。</li>
<li>立即寻址(Immediate Addressing)：地址字段指出的不是操作数地址，而是操作数本身。</li>
<li>直接寻址(Direct Addressing)：地址字段直接指出操作数在内存中地址。</li>
<li>间接寻址(Indirect Addressing)：地址字段中的D是操作数地址的指针。</li>
<li>寄存器寻址(Register Addressing)和寄存器间接寻址(Register Indirect Addressing)：寄存器中存放的是操作数和操作数在内存中的地址。</li>
<li>相对寻址方式(Relative Addressing)：把PC的内容加上指令格式中形式地址D而形成操作数的有效地址。</li>
<li>基址寻址方式(Base-Register Addressing)：把基址寄存器的内容加上指令格式中D而形成操作数的E。</li>
<li>变址寻址方式(Index Addressing)：把某个变址寄存器的内容加上指令格式中D而形成操作数的E。</li>
<li>块寻址方式(Block Addressing)：用在I/O指令中，以实现<u>外存储器</u>或<u>外围设备</u>同<u>内存</u>之间的<u>数据块传送</u>，还适用于<u>内存的数据块搬家</u>。</li>
<li>段寻址方式(Segment Addressing)：E由段寄存器的内容加上段内偏移地址而形成</li>
<li>堆栈寻址方式</li>
</ul>
</li>
</ol>
<h5 id="典型指令"><a href="#典型指令" class="headerlink" title="典型指令"></a>典型指令</h5><p><strong>指令的分类</strong></p>
<ol>
<li>数据传送指令</li>
<li>算术运算指令</li>
<li>逻辑运算指令</li>
<li>程序控制指令</li>
<li>输入输出指令</li>
<li>字符串处理指令</li>
<li>特权指令</li>
<li>其它指令</li>
</ol>
<h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h2 id="第六章-总线系统"><a href="#第六章-总线系统" class="headerlink" title="第六章 总线系统"></a>第六章 总线系统</h2><h2 id="第七章-外围设备"><a href="#第七章-外围设备" class="headerlink" title="第七章 外围设备"></a>第七章 外围设备</h2><h2 id="第八章-输入输出系统"><a href="#第八章-输入输出系统" class="headerlink" title="第八章 输入输出系统"></a>第八章 输入输出系统</h2>]]></content>
      <categories>
        <category>课程</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>fpsAim</title>
    <url>/2023/11/18/2023-11-18-fpsAim/</url>
    <content><![CDATA[<p><strong>开发文档</strong></p>
<ol>
<li><p>C++跑通demo（已完成）</p>
<ul>
<li>使用现成的模型</li>
</ul>
</li>
<li><p>修改demo，更改检测类别（人物）（已完成）</p>
</li>
<li><p>opencv实现屏幕视频流实时检测（已完成）</p>
<ul>
<li>位图转化为Mat类（已完成）</li>
</ul>
</li>
<li><p>绘制框并且在屏幕中展示（已完成）</p>
<ul>
<li><p>修改图片轨道数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">cvtColor</span>(img, img, cv::COLOR_RGBA2RGB);</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功检测，但整体帧率较低<br><img src="/images/2023-11-18-fpsAim/image-20231118202458024.png" alt="image-20231118202458024"></p>
</li>
</ul>
</li>
<li><p>优化检测速率</p>
<ul>
<li><p>使用GPU加速训练</p>
<ul>
<li><p>安装cuda和cudnn（已安装）</p>
</li>
<li><p>重新编译支持cuda的opencv版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::cuda::<span class="built_in">printShortCudaDeviceInfo</span>(cv::cuda::<span class="built_in">getDevice</span>());</span><br><span class="line"><span class="type">int</span> cudaDeviceCount = cv::cuda::<span class="built_in">getCudaEnabledDeviceCount</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenCV(4.8.0) Error: No CUDA support (The library is compiled without CUDA support) in throw_no_cuda, file F:\dev\vcpkg\buildtrees\opencv4\src\4.8.0-28394c3990.clean\modules\core\include\opencv2/core/private.cuda.hpp, line 106</span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-18-fpsAim/image-20231118204612848.png" alt="image-20231118204612848"></p>
<p>（opencv-cuda模块一次编译约为2小时…）</p>
<p><strong>编译完成</strong></p>
<p><img src="/images/2023-11-18-fpsAim/image-20231118222656606.png" alt="image-20231118222656606"></p>
<p><strong>重新打开项目测试cuda是否可用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::cuda::<span class="built_in">printCudaDeviceInfo</span>(cv::cuda::<span class="built_in">getDevice</span>());</span><br><span class="line"><span class="type">int</span> count = cv::cuda::<span class="built_in">getCudaEnabledDeviceCount</span>();</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GPU Device Count：%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2023-11-18-fpsAim/image-20231118225033140.png" alt="image-20231118225033140"></p>
<p>结果这个版本的opencv没法使用cudnn加速。</p>
<p><img src="/images/2023-11-18-fpsAim/image-20231120170426409.png" alt="image-20231120170426409"></p>
<p><strong>重新下载</strong></p>
<p>vcpkg再次编译（共计20小时），源文件近300g（幸好事先清空了F盘，后续会对源码进行删除）。</p>
<p><img src="/images/2023-11-18-fpsAim/image-20231120170712345.png" alt="image-20231120170712345"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>   **重新检测**

   ![image-20231120170630641](/images/2023-11-18-fpsAim/image-20231120170630641.png)

   ![image-20231120170841328](/images/2023-11-18-fpsAim/image-20231120170841328.png)

   还是不行

   垃圾`vcpkg`，我还是手动编译吧，使用CMAKE进行编译。
</code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/12/21/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h2><h3 id="1-本地测试"><a href="#1-本地测试" class="headerlink" title="1.本地测试"></a>1.本地测试</h3><h4 id="1-Docker部分"><a href="#1-Docker部分" class="headerlink" title="1. Docker部分"></a><strong>1. Docker部分</strong></h4><p>Docker的核心概念有以下3点</p>
<p><strong>1. 镜像（image）</strong></p>
<p><strong>2. 容器（Container）</strong></p>
<p><strong>3. 仓库（Registry）</strong></p>
<p>最后一个不用管，只需要使用docker镜像来创建容器即可，相关的操作都在容器内部进行。</p>
<p>安装docker可以参考以下这篇文章</p>
<p><a href="https://blog.csdn.net/baidu_36511315/article/details/108117826?ops_request_misc=%7B%22request%5Fid%22%3A%22170054498816800226525294%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170054498816800226525294&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-108117826-null-null.142^v96^pc_search_result_base5&amp;utm_term=docker安装&amp;spm=1018.2226.3001.4187">docker安装使用</a></p>
<p>安装完成后可以使用指令查看镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>加载镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load --input 这里填镜像名称.tar</span><br></pre></td></tr></table></figure>
<p>查看是否导入成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>创建容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run [option] 镜像名 [向启动容器中传入的命令]</span><br></pre></td></tr></table></figure>
<p>以上操作可以参考这篇文章<a href="https://blog.csdn.net/m0_37714245/article/details/81713477">Docker基本操作</a></p>
<p>进入容器后将文件传送至容器内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 本地文件路径 容器ID/容器NAME:容器内路径</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp /Users/wuhanxue/Downloads/rabbitmq_delayed_message_exchange-3.9.0.ez 1faca6a70742:/opt/rabbitmq/plugins</span><br></pre></td></tr></table></figure>
<p>然后就和在linux主机中开发是一样的了。</p>
<p>通过终端执行命令（python已经预先装好，torch等运行必须环境也已经配置完成）。</p>
<p>进入目录后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python car_speed_check.py</span><br><span class="line">python fall_det.py</span><br><span class="line">python fight_det.py</span><br></pre></td></tr></table></figure>
<p>首先在主机端依次测试</p>
<p>结果将保存在<code>test_vids_preds</code>文件夹下。</p>
<h3 id="2-部署到盒子"><a href="#2-部署到盒子" class="headerlink" title="2.部署到盒子"></a>2.部署到盒子</h3><p>模型已经预先安装好在<code>SE5/ruixin/yolov5</code>下，把文件直接拷贝进盒子即可。</p>
<p>盒子内的操作和linux操作系统一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp 本地文件路径 linaro@192.168.150.1:盒子路径</span><br></pre></td></tr></table></figure>
<p>盒子已经预先配置好了<code>sophon-sail</code>，只需要直接执行<code>SE5</code>文件夹下的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yolov5_car_speed_check_batch_opencv.py</span><br><span class="line">yolov5_fall_det_batch_opencv.py</span><br><span class="line">yolov5_fight_det_batch_opencv.py</span><br></pre></td></tr></table></figure>
<p>即可。</p>
]]></content>
  </entry>
</search>
