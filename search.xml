<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>213. House Robber II</title>
      <link href="/2023/09/17/2023-9-17-213.-House-Robber-II/"/>
      <url>/2023/09/17/2023-9-17-213.-House-Robber-II/</url>
      
        <content type="html"><![CDATA[<h2 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h2><h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213.  House Robber II"></a><a href="https://leetcode.cn/problems/house-robber-ii/description/">213.  House Robber II</a></h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/images/2023-9-17-213.-House-Robber-II/image-20230917112812696.png" alt="image-20230917112812696"></h3><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        和打家劫舍I不同的是，这个房子是首尾相连的，依旧是动态规划。问题的主要在于如何处理首尾的房子，有两种不同的方式，首房子可以访问，尾部房子不能访问；首房子不可以访问，尾部房子可以访问。分组讨论两种不同的访问方式，取最大值即可。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> max_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        max_ = <span class="built_in">max</span>(max_, dp[n<span class="number">-2</span>]);</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        max_ = <span class="built_in">max</span>(max_, dp[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>effective stl</title>
      <link href="/2023/09/16/effective%20stl/"/>
      <url>/2023/09/16/effective%20stl/</url>
      
        <content type="html"><![CDATA[<h2 id="effective-stl"><a href="#effective-stl" class="headerlink" title="effective stl"></a>effective stl</h2><h3 id="熟悉stl本身"><a href="#熟悉stl本身" class="headerlink" title="熟悉stl本身"></a>熟悉stl本身</h3><ul><li>慎重选择stl容器，每一种stl容器对应不同的使用场景，比如deque<bool>往往比vector<bool>更加合适</li><li>封装stl容器，积极的使用stl，可以高效的使用它</li><li>积极使用其对应迭代器使用的函数，比如做相加运算使用accumulate替代for循环，可以更加高效</li><li>调用对应的函数的时候，不使用过于复杂的名称，防止C++编译机制出现错误</li><li>STL并非线程安全的。它不支持并发的写入。所以在写入之前记得上锁</li><li>区别相等与等价：相等指的是里里外外完全相同，等价指的是可能只是外表相同</li><li><h1 id="include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心"><a href="#include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心" class="headerlink" title="include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心"></a>include的文件总是可以反复编写，因为他的头部都带有ifdefine，完全不用担心</h1></li><li>当查询的操作和删除的操作几乎不混在一起的时候，排序的vector会比关联容器更好</li><li>不去修改set/mutiset的吉安，修改他们可能会导致位置的行为</li><li>string的实现的多种多样，所以对应的大小也不是一样的</li></ul><h3 id="熟悉stl函数"><a href="#熟悉stl函数" class="headerlink" title="熟悉stl函数"></a>熟悉stl函数</h3><ul><li>调用empty而不是size。因为empty始终是常数时间。而size有些时候则是on</li><li>对于常见非关联容器，remove/remove-if和erase都是常见的删除用法，他能保证删除元素的同时改变容器大小。list使用remove，关联容器直接使用erase</li><li>对于已知容器的大小，可以使用reserve减少string/vector类容器增长所需要的时间，减少不必要的分配</li><li>使用swap函数对vector和string快速的放空有奇效，而且速度很快</li><li>编写比较函数的时候，我们不仅要保证operator&lt;和less<T>要具有相同的意思，还更要保证要在等值的情况下返回false，保证一个严格的弱序化</li><li>对于逐个字符的输入，可以使用istreambuf-iterator</li><li>确保使用函数的时候，目标区间足够大，否则会导致一些未知的函数</li><li>熟悉常见的排序函数，包括sort，patition等函数</li><li>容器的成员函数优先于同名算法</li><li>确保判别式是纯函数。考虑函数对象而不是函数作为stl算法的参数</li></ul><h3 id="熟悉STL容器内部的对象"><a href="#熟悉STL容器内部的对象" class="headerlink" title="熟悉STL容器内部的对象"></a>熟悉STL容器内部的对象</h3><ul><li>确保容器中的对象能高效的拷贝且正确。完整区分开深拷贝和浅拷贝</li><li>对于容器中包括了纯指针，记得要在容器对象析构前挨个delete指针。或者使用share-ptr。当然还有remove-erase也是一样</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198. 打家劫舍</title>
      <link href="/2023/09/16/2023-9-16-198.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/2023/09/16/2023-9-16-198.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2><p><img src="/images/2023-9-16-198.-打家劫舍/image-20230916084001318.png" alt="image-20230916084001318"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        经典的动态规划，小偷可以从第一家走到最后一家，走到第三家的时候，有两种偷法，偷第一家和它的前两家或者偷第二家，在往后走，我们可以<strong>不断更新走到某一家的时候前$i$家能够偷到的最大金额</strong>，不断更新，在走到某一栋房屋$i$的时候，我们有如下的递推公式：</p><p>​                                        <script type="math/tex">dp[i] = max(dp[i-1] ,dp[i-2]+nums[i])</script></p><p>最后<code>dp</code>数组的最后一位就是所有房屋能够偷到的最大金额了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1222. 可以攻击国王的皇后</title>
      <link href="/2023/09/14/2023-9-14-1222.-%E5%8F%AF%E4%BB%A5%E6%94%BB%E5%87%BB%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%9A%87%E5%90%8E/"/>
      <url>/2023/09/14/2023-9-14-1222.-%E5%8F%AF%E4%BB%A5%E6%94%BB%E5%87%BB%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%9A%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="1222-可以攻击国王的皇后"><a href="#1222-可以攻击国王的皇后" class="headerlink" title="1222. 可以攻击国王的皇后"></a><a href="https://leetcode.cn/problems/queens-that-can-attack-the-king/description/">1222. 可以攻击国王的皇后</a></h2><p><img src="/images/2023-9-14-1222.-可以攻击国王的皇后/image-20230914094038158.png" alt="image-20230914094038158"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>正难则反</strong></p><p>​        从Q去找K，有八条路，每个Q都需要找8个方向的同时还要确保路上不能有其它的Q，因此我们只需要从K出发找8个方向，如果这8个方向上有Q的话就直接返回，思路并不难。</p><p><strong>前置+和后置+</strong></p><p>​        这道题目涉及到了for循环，在这里一并解释下我困惑我已久的前置+和后置+</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br></pre></td></tr></table></figure><p>​        前置＋会比后置+拥有更高的效率，如图所示。</p><p><img src="/images/2023-9-14-1222.-可以攻击国王的皇后/image-20230914232359530.png" alt="image-20230914232359530"></p><p>​        不过对于整数的操作，编译器会进行优化，都为add1的操作。</p><p><img src="/images/2023-9-14-1222.-可以攻击国王的皇后/image-20230914232425999.png" alt="image-20230914232425999"></p><p><strong>事实上，后置递增内部需要一个临时对象，因为它必须要存放迭代器本来的位置并且返回之。</strong></p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; res, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> (&amp;arr)[<span class="number">8</span>][<span class="number">8</span>])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span> &amp;&amp; c== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">7</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt; &#123;x, y&#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x += r;</span><br><span class="line">            y += c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">queensAttacktheKing</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queens, vector&lt;<span class="type">int</span>&gt;&amp; king) &#123;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;queen:queens)&#123;</span><br><span class="line">            arr[queen[<span class="number">0</span>]][queen[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">search</span>(res, i, j, king[<span class="number">0</span>], king[<span class="number">1</span>], arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2596. 检查骑士巡视方案</title>
      <link href="/2023/09/13/2023-9-13-2596.-%E6%A3%80%E6%9F%A5%E9%AA%91%E5%A3%AB%E5%B7%A1%E8%A7%86%E6%96%B9%E6%A1%88/"/>
      <url>/2023/09/13/2023-9-13-2596.-%E6%A3%80%E6%9F%A5%E9%AA%91%E5%A3%AB%E5%B7%A1%E8%A7%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="2596-检查骑士巡视方案"><a href="#2596-检查骑士巡视方案" class="headerlink" title="2596. 检查骑士巡视方案"></a><a href="https://leetcode.cn/problems/check-knight-tour-configuration/description/">2596. 检查骑士巡视方案</a></h2><p><img src="/images/2023-9-13-2596.-检查骑士巡视方案/image-20230913120327599.png" alt="image-20230913120327599"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h4><p>​        题目给定了n的范围为[3, 7]，也就是如果采用$O(n^3)$的时间复杂度去计算，最多循环$7^6=117649$次，我们可以尝试遍历每一个值，并且通过循环的找到它的下一个位置，判断是否为合法的跳跃即可。</p><h4 id="DFS搜索"><a href="#DFS搜索" class="headerlink" title="DFS搜索"></a>DFS搜索</h4><p>​        题目是骑士在不断的跳跃，因此可以进行八方向模拟。判断好终止条件即可。终止条件：</p><ol><li>最后遍历到的数字为$n*n-1$。</li><li>遍历的次数为$n*n-1$。</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="暴力搜索-1"><a href="#暴力搜索-1" class="headerlink" title="暴力搜索"></a>暴力搜索</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">abs</span>(r - a) == <span class="number">2</span> &amp;&amp; <span class="built_in">abs</span>(c - b) == <span class="number">1</span>) || (<span class="built_in">abs</span>(r - a) == <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(c - b) == <span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidGrid</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0找到n*n-2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * n - <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 遍历数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; c++)&#123;</span><br><span class="line">                    <span class="comment">// 找到数组之后</span></span><br><span class="line">                    <span class="keyword">if</span>(grid[r][c] == i)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; n; a++)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; n; b++)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(grid[a][b] == i + <span class="number">1</span>)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(!<span class="built_in">legal</span>(r, c, a, b))&#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="DFS搜索-1"><a href="#DFS搜索-1" class="headerlink" title="DFS搜索"></a>DFS搜索</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp;grid, <span class="type">int</span> num,<span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() || c &lt; <span class="number">0</span> || c &gt;= grid.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] == grid.<span class="built_in">size</span>() * grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; num == grid.<span class="built_in">size</span>() * grid.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;r = &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot; c = &quot;</span> &lt;&lt; c;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">2</span>, c + <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">2</span>, c - <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">1</span>, c + <span class="number">2</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r + <span class="number">1</span>, c - <span class="number">2</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">2</span>, c + <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">2</span>, c - <span class="number">1</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">1</span>, c + <span class="number">2</span>) || <span class="built_in">dfs</span>(grid, num + <span class="number">1</span>, r - <span class="number">1</span>, c - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidGrid</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>630. 课程表III</title>
      <link href="/2023/09/11/2023-9-11-630.-%E8%AF%BE%E7%A8%8B%E8%A1%A8III/"/>
      <url>/2023/09/11/2023-9-11-630.-%E8%AF%BE%E7%A8%8B%E8%A1%A8III/</url>
      
        <content type="html"><![CDATA[<h1 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><a href="https://leetcode.cn/problems/course-schedule-iii/">630. 课程表 III</a></h1><p><img src="/images/2023-9-11-630.-课程表III/image-20230911135329512.png" alt="image-20230911135329512"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        这道题目我学习了<a href="[630. 课程表 III - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iii/solutions/1155605/ke-cheng-biao-iii-by-leetcode-solution-yoyz/">官方题解</a>)，简单说一下思路，方法是<strong>优先队列+贪心</strong>，修课程应该先从截止时间短的课程开始修，如果修不了也应该尽可能是该截止时间段内修了同等数目的课程中耗时最少的一种（因此使用了优先队列的数据结构，其实就是大根堆），具体的证明过程可以看看官方题解。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scheduleCourse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(courses.<span class="built_in">begin</span>(),courses.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; c0, <span class="type">const</span> <span class="keyword">auto</span>&amp; c1)&#123;</span><br><span class="line">            <span class="keyword">return</span> c0[<span class="number">1</span>] &lt; c1[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 优先队列中所有课程的总时间</span></span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; course:courses)&#123;</span><br><span class="line">            <span class="type">int</span> ti = course[<span class="number">0</span>], di =course[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(total + ti &lt;= di)&#123;</span><br><span class="line">                total += ti;</span><br><span class="line">                q.<span class="built_in">push</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>() &gt; ti)&#123;</span><br><span class="line">                total -= q.<span class="built_in">top</span>() - ti;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1462. 课程表IV</title>
      <link href="/2023/09/11/2023-9-11-1462.-%E8%AF%BE%E7%A8%8B%E8%A1%A8IV/"/>
      <url>/2023/09/11/2023-9-11-1462.-%E8%AF%BE%E7%A8%8B%E8%A1%A8IV/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="1462-课程表-IV"><a href="#1462-课程表-IV" class="headerlink" title="1462. 课程表 IV"></a><a href="https://leetcode.cn/problems/course-schedule-iv/description/">1462. 课程表 IV</a></h2><p><img src="/images/2023-9-11-1462.-课程表IV/image-20230912122234846.png" alt="image-20230912122234846"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        这道题目的关键点也在于两种不同的搜索方式。BFS和DFS。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>​        这道题要用到一个关键的排序方式，即拓扑排序。我们创建一个$numCourse×numCourse$的矩阵$isPre$，其中$isPre[x][y]$代表了课程x是否是课程y的直接或间接先决条件，若是则$isPre[x][y]=True$，若不是则$isPre[x][y]=False$。在构造完这个$isPre$数组之后，只需要$O(1)$的时间复杂度即可进行查询。</p><h4 id="BFS-剪枝"><a href="#BFS-剪枝" class="headerlink" title="BFS+剪枝"></a>BFS+剪枝</h4><p>​        广度优先搜索，我们直接模拟一下搜索的过程，比如我们需要查询课程1是否为课程5的先修课程，于是就可以从课程1出发，遍历所有修完课程1后可以修的课程，将这些课程加入队列中，再遍历队列中的每一个元素，和课程1按照同样的思路，将遍历到的元素修完之后所有可以修的课加入到队列当中，直到队列为空，队列为空之后，就返回<code>false</code>，如果在遍历的过程中找到了该节点，则返回<code>true</code>。</p><h4 id="DFS-拓扑排序"><a href="#DFS-拓扑排序" class="headerlink" title="DFS+拓扑排序"></a>DFS+拓扑排序</h4><p>深度优先搜索需要记录每一个点是否被访问，我们用$vi[x]$来表示课程x是否被访问，初始时为False。</p><p>我们从编号小到大遍历全部节点，若节点i未被访问，则进入DFS</p><ul><li>若当前节点x已被访问，则直接返回。</li><li>若当前节点x未被访问，将访问状态设置为已访问，然后继续对其全部后继节点递归进行DFS流程。将节点x置为其每一个后继节点y的先决条件，有$isPre[x][y]=True$，以及对于每一个y为先决条件的节点t，节点x同样为t的先决条件，有$isPre[x][t]=True$。</li></ul><p>遍历完成后，拓扑排序完成，矩阵$isPre$，然后我们遍历每一个查询，根据矩阵$isPre$即可得到每一个查询的结果。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="BFS-剪枝-1"><a href="#BFS-剪枝-1" class="headerlink" title="BFS+剪枝"></a>BFS+剪枝</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">      vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">      <span class="comment">// 初始化课程表的出度</span></span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">out</span>(numCourses);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;course: prerequisites)&#123;</span><br><span class="line">        out[course[<span class="number">0</span>]].<span class="built_in">push_back</span>(course[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遍历询问</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;query: queries)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bfs</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = query[<span class="number">1</span>];</span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(query[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(x == ans)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(bfs[x] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; m: out[x])&#123;</span><br><span class="line">              <span class="keyword">if</span>(bfs[m] == <span class="number">1</span>)&#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              q.<span class="built_in">push</span>(m);</span><br><span class="line">            &#125;</span><br><span class="line">            bfs[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="DFS-拓扑排序-1"><a href="#DFS-拓扑排序-1" class="headerlink" title="DFS+拓扑排序"></a>DFS+拓扑排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp; g, vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt;&amp; isPre, vector&lt;<span class="type">bool</span>&gt; &amp; vi, <span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vi[cur])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vi[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ne: g[cur])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(g, isPre, vi, ne);</span><br><span class="line">        isPre[cur][ne] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; isPre.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            isPre[cur][i] = isPre[cur][i] | isPre[ne][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个isPre数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">isPre</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (numCourses, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 创建vi数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vi</span><span class="params">(numCourses, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">g</span>(numCourses);</span><br><span class="line">        <span class="comment">// dfs需要的参数:</span></span><br><span class="line">        <span class="comment">// 1.isPre数组进行记录</span></span><br><span class="line">        <span class="comment">// 2.它的上一个节点</span></span><br><span class="line">        <span class="comment">// 3.一个visted数组，用来记录已经访问过的数字。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p:prerequisites)&#123;</span><br><span class="line">            g[p[<span class="number">0</span>]].<span class="built_in">push_back</span>(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; numCourses; i ++)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(g, isPre, vi, i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; query: queries)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(isPre[query[<span class="number">0</span>]][query[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61C</title>
      <link href="/2023/09/10/2023-9-10-CS61C/"/>
      <url>/2023/09/10/2023-9-10-CS61C/</url>
      
        <content type="html"><![CDATA[<h1 id="CS61C"><a href="#CS61C" class="headerlink" title="CS61C"></a>CS61C</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processeors:处理器</span><br><span class="line">hard disk drives:硬盘驱动器</span><br><span class="line">Number Representation:数字表示法</span><br><span class="line">biased notation:移码</span><br><span class="line">bit overflows:位溢出</span><br><span class="line">sign extension:符号扩展</span><br><span class="line">one&#x27;s complement:补码</span><br><span class="line">two&#x27;s complement:二进制补码</span><br></pre></td></tr></table></figure><h2 id="Lecture-01"><a href="#Lecture-01" class="headerlink" title="Lecture 01"></a>Lecture 01</h2><h3 id="Number-Representation"><a href="#Number-Representation" class="headerlink" title="Number Representation"></a>Number Representation</h3><p>十进制，八进制，十六进制，二进制。</p><p>计算机采用二进制。</p><h4 id="Bits-are-Bits-Bits-can-represent-ANYTHING"><a href="#Bits-are-Bits-Bits-can-represent-ANYTHING" class="headerlink" title="Bits are Bits, Bits can represent ANYTHING"></a><strong>Bits are Bits, Bits can represent ANYTHING</strong></h4><ul><li><p>26 letters require 5 bits($2^5 = 32 &gt;26$)</p></li><li><p>upper/lower case + punctuation -&gt; 7 bits(“ASCII”)</p></li><li><p>true or false (0 or 1)</p></li><li><p>ONLY ONE constraint:</p><script type="math/tex; mode=display">n digsts(base B)   <= B^n things</script></li></ul><p>位数的增加可以增加能够表示的数据，表示负数可以用第一位符号位来表示正负号。</p><h4 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a><strong>Overflow</strong></h4><p>Overflow is when the result of an arithmetic operation can’t be represented by the (FINITE) hardware bits.</p><p>Examples:<br> — unsigned:  $0b1…1 + 1_{10} = 0b0…0 = 0?$</p><p> — Two’s:        $0b01…1+1<em>{10}=0b10…0=-(2^{n-1})</em>{ten}$</p><p><img src="/images/2023-9-10-CS61C/image-20230911101431619.png" alt="image-20230911101431619"></p><p>Solutions: add more bits</p><h4 id="Sign-Extension"><a href="#Sign-Extension" class="headerlink" title="Sign Extension"></a><strong>Sign Extension</strong></h4><p> — Sign and magnitude: $0b11=0b1001$</p><p> — One’s/Two’s complement: $0b11=0b1111$</p><h4 id="Conversions"><a href="#Conversions" class="headerlink" title="Conversions"></a><strong>Conversions</strong></h4><div class="table-container"><table><thead><tr><th>$2^{10}$</th><th>$2^{20}$</th><th>$2^{30}$</th><th>$2^{40}$</th><th>$2^{50}$</th><th>$2^{60}$</th><th>$2^{70}$</th><th>$2^{80}$</th></tr></thead><tbody><tr><td>Kibi</td><td>Mebi</td><td>GiBi</td><td>Tebi</td><td>Pebi</td><td>Exbi</td><td>Eebi</td><td>Yobi</td></tr></tbody></table></div><p>移位不能改变位数能表示的距离，只是范围的移动，范围的大小并不改变。</p><p>对于<code>2&#39;s complement</code></p><p><code>overflow</code>的情况只存在于正的加正的，负的加负的。</p><h2 id="Lecture-02"><a href="#Lecture-02" class="headerlink" title="Lecture 02"></a>Lecture 02</h2><h3 id="Variable-Types"><a href="#Variable-Types" class="headerlink" title="Variable Types"></a>Variable Types</h3><p><strong>Interget sizes are machinne dependant</strong></p><p>  — Common size is 4 or 8 bytes(32/64-bit)</p><p>C must manage your memory carefully(like use ‘malloc’ and ‘free’)</p><h4 id="Syntax-and-Control-Flow"><a href="#Syntax-and-Control-Flow" class="headerlink" title="Syntax and Control Flow"></a>Syntax and Control Flow</h4><p><strong>Generic C Program Layout</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_files&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;local_files&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> macro_name macro_expr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* declare functions */</span></span><br><span class="line"><span class="comment">/* decalre global variables and structs */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span>&#123;</span><br><span class="line"><span class="comment">/* the innards */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* define other funcitons */</span></span><br></pre></td></tr></table></figure><p><strong>A variable may be initialized in its declaration;if not, it holds garbage!</strong></p><p>C语言不像java和其他语言，没有true或者false。</p><h4 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h4><ul><li><p>Consider the memory as a single huge array. Each cell of the array has its own address.(like dictionary, the address is the key, the value is a value).</p></li><li><p><strong>Don’t confuse the address referring to a memory location with the value stored there</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *x;</span><br><span class="line"> - 声明一个variable x 为 address of an int</span><br><span class="line">x = &amp;y;</span><br><span class="line"> - x 赋值address of y</span><br><span class="line">z = *x;</span><br><span class="line"> - z 赋值地址x所指向的那个值</span><br></pre></td></tr></table></figure><p>void * 可以指向任何事(generic pointer)。(Use sparingly to help avoid program bugs and other bad things)</p><ul><li><code>*</code>的位置对于编译器来说没有影响<br><code>int* x</code> is the same as <code>int *x</code></li><li><code>int *x, y, z</code> is the same as <code>int* x,y,z</code>;but NOT the same as <code>int *x, *y, *z</code>;</li></ul><p><strong>Pointer Bugs</strong></p><ul><li>C中的局部变量不被初始化，它们可以包含任何事(a.k.a “garbage”)</li><li>声明一个指针仅仅是allocates space to hold the pointer —— 它并没有分配任何被指向的东西。</li></ul><p>bad示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p, x;</span><br><span class="line">x = *p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p没有指向任何，很可能是个垃圾</span></span><br></pre></td></tr></table></figure><h2 id="Lecture-03"><a href="#Lecture-03" class="headerlink" title="Lecture 03"></a>Lecture 03</h2><h3 id="Struct-Clarification"><a href="#Struct-Clarification" class="headerlink" title="Struct Clarification"></a>Struct Clarification</h3><p>Joint struct definition and typedef</p><p> — Don’t need to name struct in this case</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="comment">/* fields */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">bar</span>;</span></span><br><span class="line">bar name1;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="comment">/* fields */</span></span><br><span class="line">&#125;bar;</span><br><span class="line">bar name1;</span><br></pre></td></tr></table></figure><h3 id="C-operators"><a href="#C-operators" class="headerlink" title="C operators"></a>C operators</h3><p><strong>Operator Precedence</strong></p><ul><li>Use parenthese sotmanipulate</li><li>Equality test (==) binds more tightly than logic(&amp;,|,&amp;&amp;,||)<br><strong>— x &amp; 1 == 0 means x&amp;(1 == 0) instead of (x&amp;1)  == 0</strong></li></ul><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a><strong>Arrays</strong></h3><p><img src="/images/2023-9-10-CS61C/image-20230913152215530.png" alt="image-20230913152215530"></p><p>结构体通过不同的排序方式进行存储，能够达到节省空间的效果。（adjust the order of the elements）</p><p>declare array时，初始化长度最好使用const变量</p><ul><li><p>ar[i] is treatd as *(ar + i)</p></li><li><p>To zero the array, the following three ways are equivalent:</p><ol><li><p>```C<br>for(int i = 0; i &lt; SIZE; i++){ar[i] = 0;}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">   for(int i = 0; i &lt; SIZE; I++)&#123;*(ar + i) = 0;&#125;</span><br></pre></td></tr></table></figure></li><li><pre><code class="lang-c">for(p = ar; p &lt; ar.SIZE(); p++)&#123;*p = 0;&#125;</code></pre></li></ol></li><li><p>These use pointer arithmetic. </p></li></ul><p>Array’s name is not a varible but a pointer  </p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
          <category> CS61C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
            <tag> CS61C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常见基本操作</title>
      <link href="/2023/09/10/C++%20%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/09/10/C++%20%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="C-常见基本操作"><a href="#C-常见基本操作" class="headerlink" title="C++ 常见基本操作"></a>C++ 常见基本操作</h1><h2 id="一-unordered-set"><a href="#一-unordered-set" class="headerlink" title="一. unordered_set"></a>一. unordered_set</h2><h3 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a><strong>引入头文件</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br></pre></td></tr></table></figure><p>​        我们可以简单地将unordered_set理解为一个无序的集合，它的底层实现是哈希表，且拥有较高的查询效率和增删效率，一般我们可以用这个数据结构判断某个元素是否已经遍历过。</p><blockquote><p>三个特性：</p><ol><li>无序</li><li>不以键值对的方式存储</li><li>不重复</li></ol></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p><strong>创建空set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; set1;</span><br></pre></td></tr></table></figure><p><strong>拷贝构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set2</span><span class="params">(set1)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>使用迭代器构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set3</span><span class="params">(set1.begin(), set1.end())</span></span>;</span><br></pre></td></tr></table></figure><p><strong>使用数组作为其初值进行构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set4</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>移动构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set5</span><span class="params">(move(set2))</span></span>;</span><br></pre></td></tr></table></figure><p>在这里解释以下什么是移动构造，<strong>移动构造是C++11标准中提供的一种新的构造方法。</strong></p><p>引用以下吾爱技术圈的例子。</p><blockquote><p>先举个生活例子，你有一本书，你不想看，但我很想看，那么我有哪些方法可以让我能看这本书？有两种做法，一种是你直接把书交给我，另一种是我去买一些稿纸来，然后照着你这本书一字一句抄到稿纸上。</p><p>显然，第二种方法很浪费时间，但这正是有些深拷贝构造函数的做法，而移动构造函数便能像第一种做法一样省时，第一种做法在 C++ 中叫做完美转发。</p><p>在C++11之前，如果要将源对象的状态转移到目标对象只能通过复制。<br>而现在在某些情况下，我们没有必要复制对象，只需要移动它们。</p><p>C++11引入移动语义：<br>源对象资源的控制权全部交给目标对象。</p></blockquote><p>复制构造和拷贝构造对比：</p><p><img src="/images/C++ 常见基本操作/image-20230910095602575.png" alt="image-20230910095602575"></p><p><strong>使用初值列表进行构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; set6 &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="unordered-set的常用内置函数"><a href="#unordered-set的常用内置函数" class="headerlink" title="unordered_set的常用内置函数"></a>unordered_set的常用内置函数</h3><p><strong>empty()函数——判断是否为空</strong></p><p>空返回true，非空返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><p><strong>find()函数——查找</strong></p><p>找到了返回迭代器；找不到返回end()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.<span class="built_in">find</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>count()函数——出现次数</strong></p><p>返回某个值出现的次数，可以用来判断某个值是否存在于某个数组中</p><p>，由于unordered_set是无序的，因此一个元素出现的次数至多为1，count()函数的返回值是0或1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.<span class="built_in">count</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>关于insert的返回值：</strong></p><p><strong>insert()只传入单个参数（待插入元素）</strong></p><blockquote><ol><li>可以用一个迭代器作为insert()的第一个参数，它指定了元素被插入的位置</li><li>在这种情况下，只会返回一个迭代器</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = words.<span class="built_in">insert</span>(pr.first, <span class="string">&quot;nine&quot;</span>); <span class="comment">// 1st arg is a hint. Returns an iterator</span></span><br></pre></td></tr></table></figure><p><strong>erase()函数——删除元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素，成功返回1，失败返回0</span></span><br><span class="line">set1.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 删除操作，成功返回下一个pair的迭代器</span></span><br><span class="line">set1.<span class="built_in">erase</span>(set1.<span class="built_in">find</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 删除set1的所有元素，返回指向end的迭代器</span></span><br><span class="line">set1.<span class="built_in">erase</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p><strong>清空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="二-queue"><a href="#二-queue" class="headerlink" title="二. queue"></a>二. queue</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>queue是一种容器转换模板，调用<code>#include &lt;queue&gt;</code>即可使用队列类。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><ol><li>```c++<br>queue<int>q1;<br>queue<double>q2;<br>queue＜char＞q3；<br>//默认为用deque容器实现的queue；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c++</span><br><span class="line">   queue＜char, list＜char＞＞q1；</span><br><span class="line">   //用list容器实现的queue </span><br><span class="line">   </span><br><span class="line">   queue＜int, deque＜int＞＞q2；</span><br><span class="line">    //用deque容器实现的queue </span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：不能用vector容器初始化queue</strong></p><p>因为queue转换器要求容器支持<code>front(), back(), push_back(), pop_left()</code>，说明queue的数据从容器后端入栈而从前端出栈。所以可以使用<code>deque</code>和<code>list</code>对<code>queue</code>进行初始化，而<code>vector</code>因其缺少<code>pop_left()</code>，不能用于<code>queue</code>。</p><p><strong>常用操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. push() 在队尾插入一个元素</span><br><span class="line">2. pop() 删除队列第一个元素</span><br><span class="line">3. size() 返回队列中元素个数</span><br><span class="line">4. empty() 如果队列空则返回true</span><br><span class="line">5. front() 返回队列中的第一个元素</span><br><span class="line">6. back() 返回队列中最后一个元素</span><br></pre></td></tr></table></figure><h2 id="三-C"><a href="#三-C" class="headerlink" title="三. C++ [](){}"></a>三. <code>C++ []()&#123;&#125;</code></h2><p>该形式是C++中的<strong>lamda函数</strong>（匿名函数）</p><p><strong>普通函数与lamda函数对比</strong></p><p>匿名函数是许多编程语言都支持的概念，有函数体，没有函数名。</p><p>函数对象能维护状态，但语法开销大，而函数指针语法开销小，却没法保存范围内的状态。</p><p><strong>基本lambda语法</strong></p><p>基本形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>[]叫做捕获说明符，表示一个lambda表达式的开始。接下来是参数列表，即这个匿名的lambda函数的参数，-&gt;return-type表示返回类型，如果没有返回类型，则可以省略这部分的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []()&#123;cout&lt;&lt;<span class="string">&quot;hello,world&quot;</span>;&#125;;</span><br><span class="line"><span class="built_in">func</span>(); <span class="comment">// now call the function</span></span><br></pre></td></tr></table></figure><p>变量捕获和lambda闭包实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">[&amp;]()&#123;cout &lt;&lt; name;&#125;();</span><br></pre></td></tr></table></figure><p>lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫闭包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[] 不截取任何变量</span><br><span class="line">[&amp;&#125; 截取外部作用域中所有变量，并作为引用在函数体中使用</span><br><span class="line">[=] 截取外部作用域中所有变量，并拷贝一份在函数体中使用</span><br><span class="line">[=, &amp;foo] 截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用</span><br><span class="line">[bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量</span><br><span class="line">[x, &amp;y] x按值传递，y按引用传递</span><br><span class="line">[this] 截取当前类中的this指针。如果已经使用了&amp;或者=就默认添加此选项。</span><br></pre></td></tr></table></figure><h2 id="四-sort"><a href="#四-sort" class="headerlink" title="四. sort"></a>四. sort</h2><p>​        <code>sort</code>是一个类似于快速排序的方法。<strong>时间复杂度是$O(nlog_2n)$，执行的效率相对来说还是比较高的。根据不同的数据量会选择不同的排序方式（结合插入排序和堆排序，根据不同的数量级别以及不同情况，能自动选用合适的排序方法）。</strong></p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>algorithm</code>是C++标准模板库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模板函数。</p><h3 id="sort（）基本使用方法"><a href="#sort（）基本使用方法" class="headerlink" title="sort（）基本使用方法"></a>sort（）基本使用方法</h3><p>​        <code>sort(begin, end, cmp)</code>是sort函数的基本使用方法。</p><p>​        <code>begin</code>是指向待排序的数组的<strong>第一个元素的指针</strong>。</p><p>​        <code>end</code>为指向<strong>最后一个元素的下一个位置的指针</strong>。</p><p>​        <code>cmp</code>为排序准则，<code>cmp</code>参数可以不写，如果不写的话，默认从小到大排序。如果我们想要从大到小排序，可以将<code>cmp</code>参数写为<code>greater&lt;int&gt;()</code>就是对int数组进行排序，当然<code>&lt;&gt;</code>中我们也可以写<code>double、long、float</code>等等。如果我们需要按照其它的排序准则，那么需要我们自己定义一个bool类型的函数来传入。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>207. 课程表</title>
      <link href="/2023/09/09/2023-9-9-207.-%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
      <url>/2023/09/09/2023-9-9-207.-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h1 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h1><p><img src="/images/2023-9-9-207.-课程表/image-20230909204417291.png" alt="image-20230909204417291"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        这道题目实际上就是一个找环的过程，构造一个有向图，以课程作为节点，以课程之间的先修关系作为有向箭头，课程之间如果不能修完，那么找它的先修课程一定会在某一个节点找到它自己。</p><p>​        换种思路看，如果课程的入度为0，代表着它之前没有先修课程，也就能直接学习，学习完这门课之后可以将这门课从图中删去，会解锁新的一批可以修的课（即入度为0的节点）。这样我们的基本思路就确定了：</p><ol><li>构造一个图（可以只构造每个节点的入度和出度）。</li><li>找到入度为0的点，如果没有，返回<code>false</code>。</li><li>在图中删去入度为0的点（即这门课解锁的课的入度减1）。</li><li>继续寻找入读为0的点，重复2，3步骤。</li><li>当所有的节点都被删除后，返回<code>true</code>。</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常见考点</title>
      <link href="/2023/09/07/C++/"/>
      <url>/2023/09/07/C++/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>float 默认是双精度浮点型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x;</span><br><span class="line">xf = <span class="number">123.1</span>; <span class="comment">// 在变量之后加f，可以变成单精度浮点型</span></span><br></pre></td></tr></table></figure><p><strong>字符型</strong>常量标识符: <code>&#39; &#39;</code></p><p><strong>字符串</strong>常量标识符:<code>&quot; &quot;</code></p><p>实型常量就是浮点数，分为十进制小数形式和指数形式两种</p><p>小数形式3.可以表示3.0，.1415可以表示0.1415</p><p>C++把这种形式的浮点数按双精度常量处理，在内存中占8个字节，如果在实数的数字之后加字母F或者f，表示此数为单精度浮点数，如3.1415F占4个字节。如果加字母L或l，表示此数为长双精度数（long double）。在VC++6.0中占8个字节。</p><p>实型常量的质素和形式一般为</p><p><code>&lt;数符&gt;数字部分E指数部分</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3.1415e0;</span><br><span class="line"></span><br><span class="line">b = 0.314.15e1;</span><br></pre></td></tr></table></figure><p><strong>字符的表示</strong></p><p>用一对单括号括起来的一个字符就是字符型常量，如<code>&#39;a&#39;,&#39;A&#39;,&#39;@&#39;,&#39;9&#39;</code>都是合法的字符串常量。</p><p>字符常量在内存中占一个字节。</p><p>由于C++将大写字母和小写字母作为不同的符号处理，因此<code>&#39;a&#39;和‘A’</code>的ASCII码值不同。</p><p>C++对一些特殊的字符，提供了特殊的表示方法，即通过转义字符来表示。转义字符表示法<strong>是在一对单撇号里加上以\开头的若干个字符，用以表示特定的字符</strong>。</p><p><strong>转义字符</strong>只代表一个字符，在内存中只占一个字节。</p><p>如<code>&#39;\a&#39;</code>表示一个警报声，会发出一个特殊的声音。</p><p>输出单个单引号<code>&#39;\&#39;&#39;</code></p><p>输出一个反斜杠<code>&#39;\\&#39;</code></p><p>空字符（’\0’）对应的ASCII码值是0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">i = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">j = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl; <span class="comment">// 输出的是65和66</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> i, j;</span><br><span class="line">i = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">j = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl</span><br></pre></td></tr></table></figure><p>字符串的结尾处添加一个空字符’\0’，用于标识一个字符串的终结。</p><p>因此，保存的空间至少是字符串的长度+1。</p><p><strong>符号常量与常变量</strong></p><p>利用预处理宏替换指令对<strong>符号常量</strong>进行说明的形式为：</p><p><code>#define</code></p><p>例如 <code>#define PI 3.1415</code></p><p><strong>变量的名字</strong></p><ol><li>见名知义</li><li>下划线或者字母开头</li></ol><p><strong>常变量</strong></p><p>用<code>const</code>定义的常变量，必须在定义的时候就给定确切的数值，并且在其后的程序中不能再改变数值。</p><p>常变量在定义的时候必须有初值，不能再赋值。</p><p>存储类型即为auto，register，static，extern中之一。</p><p>程序内共享的变量定义为static</p><p>程序间共享的变量定义为extern</p><p>在定义变量的时候，最好进行初始化，否则变量为一个随机值，后面进行操作时会出现问题。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于搭建博客的一些基础知识</title>
      <link href="/2023/09/06/2023-9-6-%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/09/06/2023-9-6-%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="博客的框架"><a href="#博客的框架" class="headerlink" title="博客的框架"></a>博客的框架</h2><p>​        我的个人博客采用的是hexo，简单介绍一下hexo，便于对博客的基本框架有一定的了解。</p><p>​        Hexo是基于Node.js的静态博客生成器，并且允许使用markdown的语法编写博客文章，并将其转化为静态HTML文件，最后在网站上展示。</p><p>​        Hexo本身是一个静态页面生成器，因此不支持动态内容，如实时评论，用户交互等，但是可以通过其它服务或者工具来集成此类功能。如Disqus、Gitalk、Valine等。</p><p><strong>了解一下几个基本概念</strong></p><p><strong>Node.js</strong></p><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于在服务器端运行 JavaScript 代码。与传统的浏览器端JavaScript不同，它提供了许多额外的API和模块，使得开发者能够访问底层操作系统的功能，比如文件系统、网络通信、操作进程等。这使得开发者可以使用JavaScript来构建服务器、命令行工具、网络应用、实时应用程序等等。</p><p><strong>NPM</strong></p><p>NPM是Node.js配套的包管理器，是世界上最大的开源软件库，什么意思呢，诸如jquery、bootstrap一类的文件都可以通过NPM下载到，程序员们如果下载什么都需要到它本身的官网上去下载，这显然是一件很麻烦的事，而NPM的出现就是为了解决这一问题，它将所有文件的包都放在了托管的平台上，程序员们只需要通过NPM就能将这些包下载下来，大大减少了人们的工作量。</p><p><strong>Git</strong></p><p>Git是一个分布式版本控制系统，用于跟踪文件和代码的变化，并协调多个开发者之间的协作功能，在开发一个大型项目时，使用git可以记录项目发生的变化，负责这一项目的程序员们也可以通过pull操作将项目下载下来在本地修改，各自托管自己负责的项目，再通过push操作将项目更新。</p><h2 id="Hexo的基本框架"><a href="#Hexo的基本框架" class="headerlink" title="Hexo的基本框架"></a>Hexo的基本框架</h2><p>​        了解了博客是由哪些工具生成，我们来解读一下Hexo的源码，找出我们平时需要在维护哪些部分。Hexo是台湾人写的，在<a href="https://hexo.io/zh-cn/docs/">官方文档</a>这方面对国人还是相当友好的。</p><h3 id="网站框架"><a href="#网站框架" class="headerlink" title="网站框架"></a>网站框架</h3><h4 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- _config.landscape.yml</span><br><span class="line">|-- _config.yml</span><br><span class="line">|-- db.json</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- package-lock.json</span><br><span class="line">|-- package.json</span><br><span class="line">|-- public</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">`-- themes</span><br></pre></td></tr></table></figure><p>上述是通过Hexo创建框架之后自动生成的文件夹，较为重要的有以下几个.</p><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h4><p>其中包含了我们的配置文件，包括主题的配置，插件，部署等等，你可以在这个文件中设置博客的标题、描述、作者、默认语言、主题、插件等信息，设置完成之后需要重新生成静态文件使其生效。</p><p>和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启 Hexo Server。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a><code>source</code></h4><p>包含了我们的资源文件，像我们写的md格式的文章以及相关的资源图都放在里面。</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a><code>public</code></h4><p>它会在我们每次使用命令<code>hexo generate</code>后生成一系列文件，用于存储生成的一系列静态网页。hexo在生成网页时，会将你的Markdown文章和主题模板转换成HTML文件，并将这些生成的文件保存在<code>public</code>文件夹中。</p><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h4><p>这是 Hexo 的插件配置文件，也位于博客根目录下。它定义了博客所使用的插件及其版本信息。当你安装或更新插件时，<code>package.json</code> 文件会被相应地更新。可以通过命令行运行 <code>npm install</code> 来安装 <code>package.json</code> 中定义的插件。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a><code>themes</code></h4><p>这个是存放主题的文件夹，通过在<code>_config.yml</code>文件中修改主题的配置即可切换主题。</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>我个人使用的主题是<code>butterfly</code>，它有较为完整的<a href="[Butterfly 安裝文檔(一">文档</a> 快速開始 | Butterfly](<a href="https://butterfly.js.org/posts/21cfbf15/))。">https://butterfly.js.org/posts/21cfbf15/))。</a></p><blockquote><p>在 hexo 的根目录创建一个文件<code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复制到 <code>_config.butterfly.yml</code>去，以后就只需要在<code>_config.butterfly.yml</code>中配置即可，原来的<code>_config.yml</code>就会失效。</p></blockquote><h3 id="文章框架"><a href="#文章框架" class="headerlink" title="文章框架"></a>文章框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line">XXX文章内容</span><br></pre></td></tr></table></figure><p>在文章的开头会预定义一些参数，如title定义标题，标定文章的标题，有一些标签需要特别注意，在这里我讲解一下。</p><h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><p>在这里引用一下官方原文，讲解的很清晰。</p><blockquote><p>官方原话：</p><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p></blockquote><p>定义的格式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><p>这样的定义代表了这篇文章的分类属于<code>Diary</code>，并且有两个标签<code>PS3</code>和<code>Games</code>。</p><p>如果这样定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>就会使得<code>Life</code>称为<code>Diary</code>的子分类，而不是并列分类。如果需要添加并列分类，是这样的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1123.最深叶节点的最近公共祖先</title>
      <link href="/2023/09/06/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/09/06/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="1123-最深叶节点的最近公共祖先"><a href="#1123-最深叶节点的最近公共祖先" class="headerlink" title="1123. 最深叶节点的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/">1123. 最深叶节点的最近公共祖先</a></h2><p><img src="/images/2023-9-6-%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20230906110858312.png" alt="image-20230906110858312"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        题目给定三个条件：</p><ol><li>树中的节点数将在[1, 1000]的范围以内。</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li>每个节点的值都是独一无二的。</li></ol><p>​        读题，如果只有一个最深叶节点，那么它本身就是它的最深叶节点。如果有两个最深叶节点，我们就应该找到一个节点，使之这两个叶节点能够存在与这两个节点的左右子树中。</p><p>​        注意到题目的节点数最大不过为1000，因此即便使用$O(n^2)$的算法也不会超时。</p><p>​        可以先遍历一遍二叉树，找到二叉树的最大深度，记为<code>max_depth</code>，再遍历一遍二叉树，判断某个节点的左右子树是否包含这个最深节点，即<code>if node1(depth==max_depth) in root-&gt;left and node2(depth==max_depth) in root-&gt;right</code>，且最好是从下往上去找，因为节点的值都是独一无二的，<strong>我们可以记录每一条到达二叉树的最深节点的路径，根据值的相等与否就能找到相应的祖先。如果路径数为1，那么就返回它本身，它本身就是最深节点的公共祖先。</strong></p><p>举几个例子，图中到达最深节点的路径有两条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 5, 2, 7] 和 [3, 5, 2, 4]，其中2是离他们最近的公共祖先。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对[0, 1, 3, null, 2]这颗二叉树，到达最深节点的路径有一条：</span><br><span class="line"></span><br><span class="line">[0, 1, 2]，那么2就是离它最近的公共祖先。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对[1, 2, 3, 4, 5, 6, 7, null, null, 8, null, 9, 10, 11, 12]这颗二叉树，到达最深节点的路径有五条：</span><br><span class="line"></span><br><span class="line">[1, 2, 4, 8]</span><br><span class="line"></span><br><span class="line">[1, 2, 5, 9]</span><br><span class="line"></span><br><span class="line">[1, 2, 5, 10]</span><br><span class="line"></span><br><span class="line">[1, 3, 6, 11]</span><br><span class="line"></span><br><span class="line">[1, 3, 6, 12]</span><br></pre></td></tr></table></figure><p>要找它们的最近公共祖先，就是它们几个中相等值的最后一位，记为<code>parent</code>。</p><p>最后遍历一遍二叉树，<code>node-&gt;val == parent</code>就是我们要的那个节点。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先取到二叉树的最大深度</span></span><br><span class="line">        <span class="type">int</span> max_depth = <span class="built_in">depth</span>(root, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; max_depth &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取遍历到最大深度的路径</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">dp_path</span>(root, path, res, max_depth);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历最大路径，找到相等的值中最后一个</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = res[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            num = res[<span class="number">0</span>][i]; <span class="comment">// 先记录某一个可能的值，再进行接下来的遍历。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j][i] != num)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到节点对应的值之后，找到对应的节点</span></span><br><span class="line">        TreeNode* node = <span class="built_in">dfs</span>(root, num);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* root, <span class="type">int</span> dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left, dp), <span class="built_in">depth</span>(root-&gt;right, dp));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dp_path</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; path, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res, <span class="type">int</span> max_depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == max_depth)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dp_path</span>(root-&gt;left, path, res, max_depth);</span><br><span class="line">        <span class="built_in">dp_path</span>(root-&gt;right, path, res, max_depth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == num)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* l = <span class="built_in">dfs</span>(root-&gt;left, num);</span><br><span class="line">        TreeNode* r = <span class="built_in">dfs</span>(root-&gt;right, num);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2594. 修车的最少时间</title>
      <link href="/2023/09/06/2023-9-6-2594.-%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"/>
      <url>/2023/09/06/2023-9-6-2594.-%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h1><h2 id="2594-修车的最少时间"><a href="#2594-修车的最少时间" class="headerlink" title="2594. 修车的最少时间"></a><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/">2594. 修车的最少时间</a></h2><p><img src="/images/2023-9-6-2594.-修车的最少时间/image-20230907141918821.png" alt="image-20230907141918821"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>​        题目给定能力值为$r$的工人可以在$ r * n ^ 2 $时间内修完<script type="math/tex">n</script>辆车，也就是说一个如果给定一个时间$t$，那么在该时间内能够修完的车的数量应该为$\lfloor\sqrt{\frac{t}{r}}\rfloor$，那么$n$个工人能够修好的车辆总数$num$就是</p><script type="math/tex; mode=display">num=\sum_{i=1}^{m}\lfloor\sqrt{\frac{t}{r_i}}\rfloor</script><p>我们注意到，这个$num$根据$t$的变化而在不断地增大。</p><p>我们就是要找到能够使得这个$num$值大于车辆的总数$n$的$t$值，这样所有的车就修好了。</p><p>每尝试一个$t$值，我们就需要计算一遍$num$，如果$t$按从小到大去遍历的话，对于$10^5$的数据量，这样的时间复杂度一定是超时的。</p><p>对于一个$t$值，任意大于等于这个$t$的数字我们都可以修好车，而小于$t$的数字我们都修不好车，不禁让我们联想到二分的方法去找到这一个$t$值，同时我们可以定义一个上界是第一位师傅修好车所需要的时间。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>能力值相同的人，在$t$时间内修好的车的个数是相等的。</p><p>根据数据范围，$ranks$中至多有100个不同的数字，我们可以统计$ ranks $中每个数字的出现次数，这样每次二分至多循环100次。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">num</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">long</span> <span class="type">long</span> t)</span></span>&#123;   <span class="comment">// 计算能修车的数量.</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ranks.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums += <span class="built_in">pow</span>(t/ranks[i], <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> right = <span class="type">long</span> <span class="built_in">long</span>(ranks[<span class="number">0</span>]) * <span class="type">long</span> <span class="built_in">long</span> (cars * cars); <span class="comment">// 第一位师傅修好车需要的时间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (right - left) &gt;&gt; <span class="number">1</span> + left; <span class="comment">// 这样定义mid是防止C++数组越界，这里的mid就代表着时间。</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;mid = &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;num(ranks, mid) = &quot;</span> &lt;&lt; <span class="built_in">num</span>(ranks, mid) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">num</span>(ranks, mid) &gt;= cars &amp;&amp; <span class="built_in">num</span>(ranks, mid - <span class="number">1</span>) &lt; cars)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span>(ranks, mid) &lt; cars)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span>(ranks, mid) &gt;= cars)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_r = ranks[<span class="number">0</span>], cnt[<span class="number">101</span>]&#123;&#125;; <span class="comment">// 数组比哈希表更快</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r : ranks) &#123;</span><br><span class="line">            min_r = <span class="built_in">min</span>(min_r, r);</span><br><span class="line">            cnt[r]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">1LL</span> * min_r * cars * cars;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (left + right) / <span class="number">2</span>, s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = min_r; r &lt;= <span class="number">100</span> &amp;&amp; s &lt; cars; r++) <span class="comment">// 至多循环 100 次</span></span><br><span class="line">                s += (<span class="type">long</span> <span class="type">long</span>) <span class="built_in">sqrt</span>(mid / r) * cnt[r];</span><br><span class="line">            (s &gt;= cars ? right : left) = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2023/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/"/>
      <url>/2023/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>​        本篇文章将持续记录刷题过程中常见的数据结构与基本操作。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算是一种对二进制数进行操作的运算。在计算机中，所有的数据都是以二进制形式存储的，位运算可以直接对二进制数的每一位进行操作，因此在一些场合下，位运算比其他运算更加高效。</p><p>对于一个数组<code>&#123;0, 2, 3&#125;</code>，我们可以存储一个二进制数，对应下标的数如果存在，则二进制该位为1，否则为0，比如说<code>0</code>在该数组中，那么该二进制数的<code>0</code>位就为1，按照<strong>从低位到高位</strong>依次类推，我们可以用<code>1101</code>表示数组<code>&#123;0,2,3&#125;</code>；再举个例子，比如说<code>&#123;1,2,3&#125;</code>可以用二进制数<code>1110</code>来表示。</p><h2 id="位运算在集合方面的应用"><a href="#位运算在集合方面的应用" class="headerlink" title="位运算在集合方面的应用"></a>位运算在集合方面的应用</h2><p>了解了位运算的基本概念之后，我们可以尝试在模拟一些集合的操作。</p><p>{1, 2, 3, 5, 7} {0, 2, 4, 5 ,7}</p><ol><li>对于求交集的操作</li></ol><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>​        哈希表（Hash table），国内也有一些算法的书籍称它为散列表，<strong>一般哈希表都是用来快速判断一个元素是否出现在集合里</strong>。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>​        将关键码和值对应的过程就叫做哈希映射，这其中涉及到了hash function， 也就是哈希函数。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>​        哈希函数通过<code>hashCode</code>将名字转化为数值，映射到哈希表上的索引数字。进行取模的操作防止索引数字超过了<code>tableSize</code>。但是这避免不了有几位学生的名字同时映射到了同一个索引下标的位置，因此引入了哈希碰撞。</p><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223821997.png" alt="image-20230905223821997">        </p><p>​        如图，小李和小王都映射到了索引下标为1的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p>​        一般对于哈希碰撞，有两种解决方法，拉链法和线性探测法。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223859549.png" alt="image-20230905223859549"></p><p>​        </p><p>（数据规模为<code>dataSize</code>，哈希表的大小为<code>tableSize</code>）        </p><p>发生冲突的位置用链表去存储，这样就可以通过索引找到小李和小王了。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>如果使用线性探测法，一定要保证<code>tableSize&gt;dataSize</code>。我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>即如果1存放了小李，下次小王又需要在1中存储时，那么小王会被放在了2的位置。所以要求<code>tableSize&gt;dataSize</code>，不然就没有空位来存放冲突的数据了。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230905223906320.png" alt="image-20230905223906320"></p><h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p>当我们遇到需要使用哈希法来解决问题的时候，我们一般会选择如下的三种数据结构。</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>其上的几个例子就是数组的代表，我们重点关注一下set。</p><p>在C++中，set和map分别提供了以下三种数据结构，其底层实现以及优劣如下表所示。</p><div class="table-container"><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p><code>std::unordered_set</code>底层实现为哈希表，<code>std::set</code>和<code>std::multiset</code>的底层实现是红黑树，<strong>红黑树是一种平衡二叉搜索树</strong>，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><div class="table-container"><table><thead><tr><th style="text-align:left">映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td style="text-align:left">std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td style="text-align:left">std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td style="text-align:left">std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p><code>std::unordered_map</code>底层实现为哈希表，<code>std::map</code> 和<code>std::multimap</code>的底层实现是红黑树。同理，<code>std::map</code>和<code>std::multimap</code>的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用<code>unordered_set</code>，因为它的<strong>查询和增删效率是最优的</strong>，如果需要集合是有序的，那么就用<code>set</code>，如果要求不仅有序还要有重复数据的话，那么就用<code>multiset</code>。</p><p>那么再来看一下<code>map</code> ，在<code>map</code>是一个<code>key-value</code>的数据结构，<code>map</code>中，对<code>key</code>是有限制，对<code>value</code>没有限制的，因为key的存储方式使用红黑树实现的。</p><p>其他语言例如：<code>java</code>里的<code>HashMap</code>，<code>TreeMap</code> 都是一样的原理。可以灵活贯通。</p><p>虽然<code>std::set</code>、<code>std::multiset</code>的底层实现是红黑树，不是哈希表，<code>std::set</code>、<code>std::multiset</code>使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即<code>key</code>和<code>value</code>。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。<code>map</code>也是一样的道理。</p><p>这里在说一下，一些C++的经典书籍上 例如<code>STL</code>源码剖析，说到了<code>hash_set hash_map</code>，这个与<code>unordered_set</code>，<code>unordered_map</code>又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是<code>unordered_set</code>在C++11的时候被引入标准库了，而<code>hash_set</code>并没有，所以建议还是使用<code>unordered_set</code>比较好，这就好比一个是官方认证的，<code>hash_set</code>，<code>hash_map</code>是C++11标准之前民间高手自发造的轮子。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%B7%E9%A2%98%E7%89%88%EF%BC%89/image-20230906223917132.png" alt="image-20230906223917132"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建-hexo</title>
      <link href="/2023/09/05/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/09/05/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><p><strong>前置知识：</strong></p><ul><li>HTML</li><li>CSS</li><li>JavaScript、jQuery</li></ul><p><strong>快速建站教程</strong></p><p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">Hexo-零基础搭建个人博客(详解)</a></p><p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210806984-1694011364573-1.png" alt="image-20230905210806984"></p><p><strong>推送至gitee仓库</strong></p><p>_config.yml文件中进行如下的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://gitee.com/zzr-rr/zzr-rr.gitee.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>在执行推送命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">推送命令</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>扩展：</p><p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p></blockquote><p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210828138.png" alt="image-20230905210828138">推送完成的界面。</p><p>由于gitee有一堆显示，我将他连接到github，并且部署到我的仓库。</p><p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE1%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230905210856266.png" alt="image-20230905210856266"></p><p>了解一下hexo吧，hexo的基本配置 <code>.config.yaml</code>文件下的各种参数</p><p><strong>网站</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table></div><p><strong>网址</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>permalink</code></td><td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr></tbody></table></div><p><strong>如何对hexo网站进行修改，参考hexo的官方文档</strong></p><p><a href="https://hexo.io/zh-cn/api/">API | Hexo</a></p><h3 id="在git过程中遇到的一些问题"><a href="#在git过程中遇到的一些问题" class="headerlink" title="在git过程中遇到的一些问题"></a>在git过程中遇到的一些问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/Zzr-rr/Zzr-rr.github.io.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>打开<code>git bash</code>，解除SSL认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><p>git可能隔一段时间就会出现这个问题，及时修改即可。</p><p>因为是国外的网站，github经常连接超时，隔一段时间试试。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
